<!-- Slide 6c: Phase 1 - NPR Preview -->
<section class="slide" data-index="6c">
  <div class="slide-header">
    <h1 class="slide-title">Phase 1: Hand-Drawn 2.5D Preview</h1>
    <div class="phase-subtitle">The "wow factor" - artist's sketch aesthetic</div>
  </div>

  <div class="two-column" style="margin-top: 2rem; gap: 3rem;">
    <div class="left-column">
      <h3 style="color: var(--accent-primary); margin-bottom: 1.5rem;">The Vision</h3>
      <p style="font-size: 1.05rem; line-height: 1.7; margin-bottom: 1.5rem;">
        Walk through the design in 3D with a <span class="highlight">hand-drawn sketch aesthetic</span> -
        like an architect's illustration come to life.
      </p>

      <ul class="bullet-list" style="font-size: 0.95rem;">
        <li><span class="highlight">Sprite-based plants</span> - Simple "cardboard cutout" style</li>
        <li><span class="highlight">Procedural pencil shaders</span> - GLSL sketch effects</li>
        <li><span class="highlight">Basic terrain</span> - Flat or simple elevation</li>
        <li><span class="highlight">First-person walk</span> - Explore the design</li>
      </ul>

      <p style="margin-top: 1.5rem; color: var(--text-secondary); font-size: 0.9rem; font-style: italic;">
        Note: This is optional for Phase 1. If Annie's team values the 2D tools more, we focus there first.
      </p>
    </div>

    <div class="right-column" style="background: rgba(52, 211, 153, 0.05); border: 1px solid var(--accent-primary); border-radius: 12px; padding: 1.5rem; display: flex; flex-direction: column; justify-content: center; align-items: center;">
      <h4 style="color: var(--accent-primary); margin-bottom: 1rem;">Live Shader Demo</h4>
      <div style="position: relative; width: 100%; aspect-ratio: 1; max-width: 400px; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
        <canvas id="nprShaderCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
      </div>
      <p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-top: 1rem;">
        <em>Procedural colored pencil sketch rendering</em>
      </p>
    </div>
  </div>

  <div style="margin-top: 2.5rem; padding: 1.5rem; background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; border-radius: 8px;">
    <p style="font-size: 0.95rem; line-height: 1.6; margin: 0;">
      <strong style="color: #ffc107;">Why this aesthetic?</strong>
      Differentiates from competitors' clinical 3D renderings. Aligns with landscape architecture presentation style.
      Performant enough for real-time on modest hardware. Makes designs feel artistic, not robotic.
    </p>
  </div>
</section>

<style>
.two-column {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
}

.phase-subtitle {
  font-size: 1.1rem;
  color: var(--text-secondary);
  margin-top: 0.5rem;
  font-weight: 400;
}
</style>

<script>
// Initialize NPR shader demo when slide is visible
let shaderInitialized = false;
function initShader() {
  if (shaderInitialized) {
    console.log('Shader already initialized, skipping');
    return;
  }

  const canvas = document.getElementById('nprShaderCanvas');
  if (!canvas) {
    console.error('Canvas not found!');
    return;
  }
  console.log('Initializing shader on canvas:', canvas);
  shaderInitialized = true;

  const gl = canvas.getContext('webgl2');
  if (!gl) {
    console.error('WebGL 2.0 not supported - falling back to WebGL 1.0');
    const gl1 = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl1) {
      console.error('WebGL not supported at all');
      canvas.getContext('2d').fillText('WebGL not supported', 50, 50);
      return;
    }
    console.error('This shader requires WebGL 2.0');
    return;
  }
  console.log('Using WebGL 2.0');

  // Set canvas size to match display size
  const rect = canvas.getBoundingClientRect();
  const size = Math.min(rect.width, rect.height) || 512;
  canvas.width = size;
  canvas.height = size;

  console.log('Canvas size:', canvas.width, 'x', canvas.height);

  // Vertex shader (standard quad) - WebGL 2.0 / GLSL ES 3.00
  const vertexShaderSource = `#version 300 es
in vec2 position;
void main() {
  gl_Position = vec4(position, 0.0, 1.0);
}
`;

  // Fragment shader loaded from external file
  // IMPORTANT: No whitespace before #version directive
  const fragmentShaderSource = `{{SHADER:shaders/cube-circle-fragment.glsl}}`;

  // Compile shaders
  function compileShader(source, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
  const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

  if (!vertexShader || !fragmentShader) return;

  // Link program
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    return;
  }

  gl.useProgram(program);

  // Setup geometry (fullscreen quad)
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
     1,  1
  ]), gl.STATIC_DRAW);

  const positionLocation = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  // Set viewport
  gl.viewport(0, 0, canvas.width, canvas.height);
  console.log('Viewport set to:', canvas.width, 'x', canvas.height);

  // Get uniform locations (MUST be done AFTER useProgram and BEFORE first render)
  // Note: Must ensure program is current before getting locations
  gl.useProgram(program);

  const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
  const iTimeLocation = gl.getUniformLocation(program, 'iTime');

  console.log('Uniform locations:', {
    iResolution: iResolutionLocation,
    iTime: iTimeLocation
  });

  // Verify uniforms were found (null or -1 means not found)
  if (!iResolutionLocation || iResolutionLocation === -1) {
    console.error('Could not find uniform: iResolution');
  }
  if (!iTimeLocation || iTimeLocation === -1) {
    console.error('Could not find uniform: iTime');
  }

  // Render loop
  let startTime = Date.now();
  function render() {
    const currentTime = (Date.now() - startTime) / 1000.0;

    // Only set uniforms if locations are valid
    if (iResolutionLocation && iResolutionLocation !== -1) {
      gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
    }
    if (iTimeLocation && iTimeLocation !== -1) {
      gl.uniform1f(iTimeLocation, currentTime);
    }

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
  }

  console.log('Starting render loop');
  render();
}

// Try to initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initShader);
} else {
  initShader();
}

// Also try again on window load
window.addEventListener('load', function() {
  const canvas = document.getElementById('nprShaderCanvas');
  if (canvas && !canvas.getContext('webgl')) {
    initShader();
  }
});
</script>
