<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Flora: Seeding the Future of Landscape Design</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&family=Playfair+Display:wght@400;700;900&display=swap" rel="stylesheet">

    <!-- Code syntax highlighting with Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

    <!-- Leaflet CSS for GIS demo -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">

    <!-- D3 UMD (exposes window.d3) -->
    <script src="https://d3js.org/d3.v7.min.js" defer></script>

    <!-- D3FC UMD bundle (exposes window.fc, includes label-layout) -->
    <script src="https://unpkg.com/d3fc@15" defer></script>

    <style>
:root {
      --bg-primary: #0a1f1e;
      --bg-secondary: #0f2826;
      --bg-gradient-1: #1a3633;
      --bg-gradient-2: #0d2422;
      --text-primary: #f0fdf9;
      --text-secondary: #a7f3d0;
      --text-muted: #6ee7b7;
      --accent-primary: #34d399;
      --accent-secondary: #10b981;
      --accent-glow: #86efac;
      --card-bg: rgba(16, 185, 129, 0.05);
      --border-color: rgba(52, 211, 153, 0.2);
      --shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.3);
      --shadow-glow: 0 0 60px rgba(52, 211, 153, 0.15);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
      -webkit-text-size-adjust: 100%;
    }

    body {
      background: radial-gradient(ellipse at top right, var(--bg-gradient-1), var(--bg-primary)),
                  radial-gradient(ellipse at bottom left, var(--bg-gradient-2), var(--bg-primary));
      color: var(--text-primary);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      font-weight: 400;
      line-height: 1.6;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(52, 211, 153, 0.03) 1px, transparent 1px);
      background-size: 50px 50px;
      animation: drift 60s linear infinite;
      pointer-events: none;
    }

    @keyframes drift {
      to { transform: translate(50px, 50px); }
    }

    #deck {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .slide {
      position: absolute;
      inset: 0;
      padding: 8vh 8vw;
      display: flex;
      flex-direction: column;
      justify-content: center;
      opacity: 0;
      transform: translateX(100px);
      transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .slide.active {
      opacity: 1;
      transform: translateX(0);
      pointer-events: all;
    }

    .slide.prev {
      transform: translateX(-100px);
    }

    /* Title Slide */
    .title-slide {
      text-align: center;
      align-items: center;
    }

    .logo-container {
      position: relative;
      margin-bottom: 3rem;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .logo {
      width: 180px;
      height: 180px;
      background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-glow), var(--shadow-xl);
      position: relative;
      overflow: hidden;
    }

    .logo::before {
      content: '🌿';
      font-size: 80px;
      filter: brightness(0) invert(1);
      z-index: 2;
      position: relative;
    }

    .logo::after {
      content: '';
      position: absolute;
      inset: -50%;
      background: conic-gradient(from 0deg, transparent, rgba(255,255,255,0.1), transparent);
      animation: spin 10s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    h1.main-title {
      font-family: 'Playfair Display', serif;
      font-size: clamp(3rem, 8vw, 5.5rem);
      font-weight: 900;
      background: linear-gradient(135deg, var(--text-primary), var(--accent-glow));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 1rem;
      letter-spacing: -0.02em;
    }

    h2.main-subtitle {
      font-size: clamp(1.2rem, 3vw, 1.8rem);
      font-weight: 300;
      color: var(--text-secondary);
      letter-spacing: 0.05em;
    }

    /* Regular Slides */
    .slide-header {
      margin-bottom: 3rem;
    }

    h1.slide-title {
      font-family: 'Playfair Display', serif;
      font-size: clamp(2rem, 5vw, 3.5rem);
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: 0.5rem;
      position: relative;
      display: inline-block;
    }

    h1.slide-title::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 0;
      width: 60px;
      height: 3px;
      background: linear-gradient(90deg, var(--accent-primary), transparent);
      border-radius: 2px;
    }

    .slide-content {
      font-size: clamp(1.1rem, 2vw, 1.4rem);
      line-height: 1.8;
    }

    /* Cards and Lists */
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
      margin-top: 2rem;
    }

    .feature-card {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 1.5rem;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .feature-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
      transform: translateX(-100%);
      transition: transform 0.6s ease;
    }

    .feature-card:hover {
      transform: translateY(-4px);
      border-color: var(--accent-primary);
      box-shadow: 0 10px 30px rgba(52, 211, 153, 0.2);
    }

    .feature-card:hover::before {
      transform: translateX(0);
    }

    .feature-icon {
      font-size: 2rem;
      margin-bottom: 0.75rem;
    }

    .feature-title {
      font-weight: 600;
      font-size: 1.2rem;
      color: var(--accent-glow);
      margin-bottom: 0.5rem;
    }

    .feature-desc {
      color: var(--text-secondary);
      font-size: 1rem;
      line-height: 1.6;
    }

    /* Bullet Points */
    .bullet-list {
      list-style: none;
      padding: 0;
    }

    .bullet-list li {
      position: relative;
      padding-left: 2rem;
      margin-bottom: 1.5rem;
      font-size: clamp(1rem, 2vw, 1.3rem);
      animation: slideIn 0.6s ease backwards;
    }

    .bullet-list li:nth-child(1) { animation-delay: 0.1s; }
    .bullet-list li:nth-child(2) { animation-delay: 0.2s; }
    .bullet-list li:nth-child(3) { animation-delay: 0.3s; }
    .bullet-list li:nth-child(4) { animation-delay: 0.4s; }
    .bullet-list li:nth-child(5) { animation-delay: 0.5s; }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .bullet-list li::before {
      content: '▸';
      position: absolute;
      left: 0;
      color: var(--accent-primary);
      font-weight: 700;
      font-size: 1.2em;
    }

    .highlight {
      color: var(--accent-glow);
      font-weight: 600;
    }

    /* Metrics */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 2rem;
      margin-top: 3rem;
    }

    .metric-card {
      text-align: center;
      animation: fadeInUp 0.6s ease backwards;
    }

    .metric-card:nth-child(1) { animation-delay: 0.1s; }
    .metric-card:nth-child(2) { animation-delay: 0.2s; }
    .metric-card:nth-child(3) { animation-delay: 0.3s; }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .metric-value {
      font-size: clamp(2.5rem, 5vw, 4rem);
      font-weight: 900;
      color: var(--accent-primary); /* Fallback color */
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-glow));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
      display: inline-block; /* Ensure gradient covers full text */
    }

    .metric-label {
      font-size: 1.1rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    /* Team Section */
    .team-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 2rem;
      margin-top: 3rem;
    }

    .team-member {
      text-align: center;
    }

    .member-avatar {
      width: 100px;
      height: 100px;
      background: linear-gradient(135deg, var(--bg-gradient-1), var(--accent-primary));
      border-radius: 50%;
      margin: 0 auto 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .member-name {
      font-weight: 700;
      font-size: 1.2rem;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .member-role {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    /* Controls */
    .controls {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 1.5rem;
      background: rgba(10, 31, 30, 0.8);
      backdrop-filter: blur(10px);
      padding: 0.75rem 1.5rem;
      border-radius: 100px;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-xl);
      z-index: 100;
      transition: opacity 1s ease;
      opacity: 1;
    }

    .controls.fade-out {
      opacity: 0;
      pointer-events: none;
    }

    .controls.fade-in {
      opacity: 1;
      pointer-events: all;
    }

    .controls button {
      background: transparent;
      border: 2px solid var(--accent-primary);
      color: var(--accent-primary);
      padding: 0.5rem 1rem;
      border-radius: 50px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9rem;
    }

    .controls button:hover {
      background: var(--accent-primary);
      color: var(--bg-primary);
      transform: scale(1.05);
    }

    #counter {
      font-weight: 500;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    /* Progress Bar */
    .progress-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(255,255,255,0.1);
      z-index: 100;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-secondary), var(--accent-primary));
      transition: width 0.3s ease;
      box-shadow: 0 0 10px var(--accent-primary);
    }

    /* Help */
    .help {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      color: var(--text-muted);
      font-size: 0.85rem;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }

    .help:hover {
      opacity: 1;
    }

    kbd {
      background: rgba(255,255,255,0.1);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.9em;
    }

    /* Mobile indicator */
    .mobile-swipe-hint {
      display: none;
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--text-muted);
      font-size: 0.85rem;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    /* Enhanced Mobile Responsive - Small Phones */
    @media (max-width: 480px) {
      .slide {
        padding: 1rem;
        padding-top: 3rem;
        padding-bottom: 7rem; /* Increased to account for controls */
        justify-content: flex-start;
      }

      /* Make slides scrollable on mobile */
      .slide.active {
        overflow-y: auto;
      }

      /* Shrink logo on mobile */
      .logo {
        width: 120px;
        height: 120px;
      }

      .logo::before {
        font-size: 60px;
      }

      .logo-container {
        margin-bottom: 2rem;
      }

      /* Adjust title sizes */
      h1.main-title {
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
      }

      h2.main-subtitle {
        font-size: 1rem;
        padding: 0 1rem;
      }

      h1.slide-title {
        font-size: 1.75rem;
        margin-bottom: 1rem;
      }

      .slide-header {
        margin-bottom: 1.5rem;
      }

      /* Stack all grids vertically */
      .feature-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .metrics-grid {
        grid-template-columns: 1fr;
        gap: 1.5rem;
        margin-top: 2rem;
      }

      .team-grid {
        grid-template-columns: 1fr;
        gap: 1.5rem;
        margin-top: 2rem;
      }

      /* Smaller cards on mobile */
      .feature-card {
        padding: 1rem;
      }

      .feature-icon {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
      }

      .feature-title {
        font-size: 1.1rem;
      }

      .feature-desc {
        font-size: 0.9rem;
      }

      /* Adjust metrics */
      .metric-value {
        font-size: 2rem;
      }

      .metric-label {
        font-size: 0.9rem;
      }

      /* Smaller avatars */
      .member-avatar {
        width: 80px;
        height: 80px;
        font-size: 2rem;
      }

      .member-name {
        font-size: 1.1rem;
      }

      .member-role {
        font-size: 0.85rem;
      }

      /* Adjust bullet points */
      .bullet-list li {
        font-size: 0.95rem;
        margin-bottom: 1rem;
        padding-left: 1.5rem;
      }

      /* Compact mobile controls */
      .controls {
        bottom: 0.5rem;
        left: 1rem;
        right: 1rem;
        width: auto;
        transform: none;
        padding: 0.4rem;
        gap: 0;
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        align-items: center;
        background: rgba(10, 31, 30, 0.95);
        border-radius: 18px;
        max-width: none;
        height: 56px; /* Fixed height for consistency */
        transition: opacity 1s ease;
      }

      .controls.fade-out {
        opacity: 0;
        pointer-events: none;
      }

      .controls.fade-in {
        opacity: 1;
        pointer-events: all;
      }

      .controls button {
        padding: 0;
        width: 44px;
        height: 44px;
        font-size: 1.3rem;
        min-width: auto;
        border-width: 2px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(52, 211, 153, 0.1);
      }

      .controls button:active {
        transform: scale(0.95);
        background: var(--accent-primary);
        color: var(--bg-primary);
      }

      #prev {
        justify-self: start;
        margin-left: 0.4rem;
      }

      #next {
        justify-self: end;
        margin-right: 0.4rem;
      }

      #counter {
        font-size: 0.9rem;
        white-space: nowrap;
        color: var(--accent-glow);
        font-weight: 600;
        padding: 0 0.75rem;
      }

      /* Hide help text on mobile */
      .help {
        display: none;
      }

      /* Better swipe hint */
      .mobile-swipe-hint {
        display: block;
        bottom: 70px; /* Adjusted for new control height */
        font-size: 0.7rem;
        color: var(--text-muted);
        background: rgba(10, 31, 30, 0.7);
        padding: 0.2rem 0.8rem;
        border-radius: 15px;
        backdrop-filter: blur(10px);
      }

      /* Adjust general text */
      .slide-content {
        font-size: 1rem;
        line-height: 1.6;
      }

      .slide-content p {
        font-size: 0.95rem;
        margin-bottom: 1rem;
      }
    }

    /* Medium Mobile */
    @media (min-width: 481px) and (max-width: 768px) {
      .slide {
        padding: 2rem;
        padding-top: 3rem;
        padding-bottom: 6rem; /* Added more padding for controls */
      }
      
      .feature-grid {
        grid-template-columns: 1fr;
      }

      h1.main-title {
        font-size: 3.5rem;
      }

      h1.slide-title {
        font-size: 2.25rem;
      }

      .metrics-grid {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      }
      
      .controls {
        bottom: 1rem;
        padding: 0.65rem 1.25rem;
      }

      .controls button {
        padding: 0.6rem 1.1rem;
        font-size: 1rem;
      }
      
      .help {
        display: none;
      }

      .mobile-swipe-hint {
        display: block;
      }
    }

    /* Landscape orientation for small screens */
    @media (max-height: 500px) and (orientation: landscape) {
      .slide {
        padding: 1rem 2rem;
        padding-bottom: 4rem;
      }

      .logo {
        width: 80px;
        height: 80px;
      }

      .logo::before {
        font-size: 40px;
      }

      h1.main-title {
        font-size: 2rem;
      }

      h1.slide-title {
        font-size: 1.5rem;
      }

      .slide-header {
        margin-bottom: 1rem;
      }

      .metrics-grid,
      .team-grid {
        grid-template-columns: repeat(3, 1fr);
      }

      .controls {
        padding: 0.5rem 1rem;
      }
    }

    @media print {
      body {
        background: white;
        color: #111;
      }
      
      #deck {
        height: auto;
      }
      
      .slide {
        position: static;
        page-break-after: always;
        opacity: 1;
        transform: none;
      }
      
      .controls, .help, .progress-container, .mobile-swipe-hint {
        display: none;
      }
    }

        /* Code block styling */
        pre code {
            border: 1px solid rgba(255,255,255,0.1) !important;
            border-radius: 12px !important;
            padding: 20px !important;
            display: block;
        }

        /* Maintain our colored container backgrounds */
        .bad-code, .code-example {
            background: linear-gradient(180deg, rgba(255,123,123,0.08), rgba(255,123,123,0.04)) !important;
            border-left: 4px solid var(--accent3) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .good-code, .code-solution {
            background: linear-gradient(180deg, rgba(155,255,176,0.08), rgba(155,255,176,0.04)) !important;
            border-left: 4px solid var(--accent2) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .implementation-example {
            background: linear-gradient(180deg, rgba(156,39,176,0.08), rgba(156,39,176,0.04)) !important;
            border-left: 4px solid #9C27B0 !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .universal-class {
            background: linear-gradient(180deg, rgba(33,150,243,0.08), rgba(33,150,243,0.04)) !important;
            border-left: 4px solid #2196F3 !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .approach-bad, .approach-good {
            background: rgba(255,255,255,0.04) !important;
            border: 1px solid rgba(255,255,255,0.08) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        /* Crisp "halo" under label text to keep it readable */
        svg text {
            paint-order: stroke;
            stroke: rgba(8,12,16,.75);
            stroke-width: 3;
        }
        /* Optional: keep strokes consistent when scaling */
        svg *[stroke] {
            vector-effect: non-scaling-stroke;
        }
    </style>

    <!-- Math rendering with MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']]
            },
            options: {
                renderActions: {
                    addMenu: []  // Disable context menu for cleaner presentation
                }
            }
        };
    </script>
</head>
<body>
    <div class="progress-container">
        <div class="progress-bar" id="progress"></div>
    </div>

    <div id="deck">
        <section class="slide title-slide active" data-index="1">
      <div class="logo-container">
        <div class="logo"></div>
      </div>
      <h1 class="main-title">Project Flora</h1>
      <h2 class="main-subtitle">The Operating System for Sustainable Landscape Design</h2>
    </section>
<section class="slide" data-index="2">
      <div class="slide-header">
        <h1 class="slide-title">The $180B Opportunity</h1>
      </div>
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-value">$180B</div>
          <div class="metric-label">U.S. Landscaping Market</div>
        </div>
        <div class="metric-card">
          <div class="metric-value">$3B→$5.6B</div>
          <div class="metric-label">Software Market by 2030</div>
        </div>
        <div class="metric-card">
          <div class="metric-value">700K+</div>
          <div class="metric-label">U.S. Businesses</div>
        </div>
      </div>
      <ul class="bullet-list" style="margin-top: 3rem;">
        <li>72% of landscaping businesses have <span class="highlight">fewer than 10 employees</span></li>
        <li>Post-pandemic <span class="highlight">outdoor living boom</span> driving demand</li>
        <li>This is the <span class="highlight clickable-term" onclick="showAltiumModal()">Altium vs. OrCAD moment <span class="info-icon">ⓘ</span></span> for landscaping</li>
      </ul>

      <!-- Modal for Altium explanation -->
      <div id="altiumModal" class="modal-overlay" onclick="hideAltiumModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
          <button class="modal-close" onclick="hideAltiumModal()">×</button>
          <h3 class="modal-title">The Altium vs. OrCAD Story</h3>
          <div class="modal-body">
            <p><strong>OrCAD:</strong> Dominant but dated PCB design tool. Powerful but clunky, expensive, steep learning curve.</p>
            <p><strong>Altium:</strong> Modern alternative with better UX, more intuitive interface, and integrated workflow. Disrupted the market by being more accessible while still professional.</p>
            <p class="modal-highlight">🎯 <strong>The Parallel:</strong> AutoCAD/Vectorworks are the "OrCAD" of landscaping. Flora is positioned to be the "Altium" - bringing modern UX and intelligence to an underserved market.</p>
          </div>
        </div>
      </div>
    </section>

    <style>
      .clickable-term {
        cursor: pointer;
        position: relative;
        border-bottom: 2px dotted var(--accent-primary);
      }

      .clickable-term:hover {
        color: var(--accent-glow);
      }

      .info-icon {
        font-size: 0.85em;
        margin-left: 0.25rem;
        opacity: 0.8;
      }

      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(4px);
        z-index: 10000;
        justify-content: center;
        align-items: center;
      }

      .modal-overlay.active {
        display: flex;
      }

      .modal-content {
        background: linear-gradient(135deg, var(--bg-gradient-1), var(--bg-secondary));
        border: 2px solid var(--accent-primary);
        border-radius: 16px;
        padding: 2rem;
        max-width: 600px;
        width: 90%;
        box-shadow: var(--shadow-glow), var(--shadow-xl);
        position: relative;
        animation: modalSlideIn 0.3s ease;
      }

      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .modal-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: transparent;
        border: none;
        color: var(--text-primary);
        font-size: 2rem;
        cursor: pointer;
        line-height: 1;
        padding: 0;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        transition: all 0.2s;
      }

      .modal-close:hover {
        background: var(--accent-primary);
        color: var(--bg-primary);
        transform: rotate(90deg);
      }

      .modal-title {
        font-family: 'Playfair Display', serif;
        font-size: 1.8rem;
        color: var(--accent-glow);
        margin-bottom: 1.5rem;
        padding-right: 2rem;
      }

      .modal-body p {
        margin-bottom: 1rem;
        line-height: 1.6;
        color: var(--text-primary);
      }

      .modal-body strong {
        color: var(--accent-primary);
      }

      .modal-highlight {
        background: rgba(52, 211, 153, 0.1);
        border-left: 3px solid var(--accent-primary);
        padding: 1rem;
        border-radius: 4px;
        margin-top: 1.5rem;
      }
    </style>

    <script>
      function showAltiumModal() {
        document.getElementById('altiumModal').classList.add('active');
      }

      function hideAltiumModal() {
        document.getElementById('altiumModal').classList.remove('active');
      }

      // Close modal on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          hideAltiumModal();
        }
      });
    </script>
<section class="slide" data-index="3">
      <div class="slide-header">
        <h1 class="slide-title">Current Tools Are Broken</h1>
      </div>
      <div class="feature-grid">
        <div class="feature-card">
          <div class="feature-icon">🏗️</div>
          <div class="feature-title">Pro Tools</div>
          <div class="feature-desc">AutoCAD, Vectorworks: Powerful but clunky, expensive, and plant-ignorant</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">📱</div>
          <div class="feature-title">Consumer Apps</div>
          <div class="feature-desc">iScape, Home Outside: Pretty but shallow – basically clip art</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">✏️</div>
          <div class="feature-title">Current Reality</div>
          <div class="feature-desc">Annie does everything manually in Illustrator with no intelligence</div>
        </div>
      </div>
    </section>
<section class="slide" data-index="4">
      <div class="slide-header">
        <h1 class="slide-title">Flora: Intelligence Meets Beauty</h1>
      </div>
      <div class="feature-grid">
        <div class="feature-card">
          <div class="feature-icon">📍</div>
          <div class="feature-title">Instant Site Setup</div>
          <div class="feature-desc">Type address → get parcel + imagery instantly</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">🌿</div>
          <div class="feature-title">Plant Intelligence</div>
          <div class="feature-desc">Native species, zones, spacing – built-in ecology</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">🎨</div>
          <div class="feature-title">Beautiful Design</div>
          <div class="feature-desc">Illustrator feel for outdoor spaces</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">📋</div>
          <div class="feature-title">Auto Takeoffs</div>
          <div class="feature-desc">One-click plant lists and sales-ready PDFs</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">🎮</div>
          <div class="feature-title">3D Walkthrough</div>
          <div class="feature-desc">Doom-style exploration of designs</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">🤖</div>
          <div class="feature-title">AI-Powered</div>
          <div class="feature-desc">Smart recommendations and plant ID</div>
        </div>
      </div>
    </section>
<!-- Slide 5: MVP Demo Flow -->
    <section class="slide" data-index="5">
      <div class="slide-header">
        <h1 class="slide-title">MVP in 4 Simple Steps</h1>
      </div>
      <ul class="bullet-list">
        <li><span class="highlight">Step 1:</span> Enter address → site instantly appears with parcel + aerial</li>
        <li><span class="highlight">Step 2:</span> Drag & drop native plants with smart filters and spacing</li>
        <li><span class="highlight">Step 3:</span> Generate branded plant list PDF with counts & species</li>
        <li><span class="highlight">Step 4:</span> Click to walk through your design in 3D (optional wow)</li>
      </ul>
    </section>

<!-- Slide 6: Phase 1 Overview -->
<section class="slide" data-index="6">
  <div class="slide-header">
    <h1 class="slide-title">Phase 1: Prove Value with Annie</h1>
    <div class="phase-subtitle">Validation before vision</div>
  </div>

  <div class="two-column" style="margin-top: 2rem; gap: 3rem;">
    <div class="left-column">
      <h3 style="color: var(--accent-primary); margin-bottom: 1.5rem;">The Goal</h3>
      <p style="font-size: 1.1rem; line-height: 1.7; margin-bottom: 1rem;">
        Get Annie's nursery staff <span class="highlight">designing with Flora for real client projects</span> within weeks.
      </p>
      <p style="color: var(--text-secondary); line-height: 1.6;">
        Establish a user feedback loop. Learn which features provide the most value. Prove measurable time savings vs. manual Illustrator workflow.
      </p>
    </div>

    <div class="right-column">
      <h3 style="color: var(--accent-primary); margin-bottom: 1.5rem;">The Constraints</h3>
      <ul class="bullet-list" style="font-size: 0.95rem;">
        <li><span class="highlight">Geography:</span> Tampa Bay + Sarasota only</li>
        <li><span class="highlight">Plants:</span> ~250 species Annie actually sells</li>
        <li><span class="highlight">Platform:</span> Illustrator plugin (not web app)</li>
        <li><span class="highlight">Timeline:</span> Weeks to pilot, not months</li>
      </ul>
    </div>
  </div>

  <div style="margin-top: 2.5rem; padding: 1.5rem; background: rgba(52, 211, 153, 0.1); border-left: 4px solid var(--accent-primary); border-radius: 8px;">
    <p style="font-size: 1.05rem; line-height: 1.7; margin: 0;">
      <strong style="color: var(--accent-primary);">Why start small?</strong>
      Risk reduction. We validate the business model and learn what matters <em>before</em> building a massive platform.
      Annie's feedback guides Phase 2 priorities.
    </p>
  </div>
</section>

<style>
.two-column {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
}

.phase-subtitle {
  font-size: 1.1rem;
  color: var(--text-secondary);
  margin-top: 0.5rem;
  font-weight: 400;
}
</style>

<!-- Slide 6a: Phase 1 - GIS & Data -->
<section class="slide" data-index="6a">
  <div class="slide-header">
    <h1 class="slide-title">Phase 1: GIS & Plant Data</h1>
    <div class="phase-subtitle">Tampa Bay + Sarasota region</div>
  </div>

  <div class="feature-grid" style="margin-top: 2rem;">
    <div class="feature-card">
      <div class="feature-icon">📍</div>
      <div class="feature-title">Regional GIS Pipeline</div>
      <div class="feature-desc">Tampa Bay + Sarasota parcels • Local aerial imagery • Soil data • Working pipeline for pilot region</div>
    </div>

    <div class="feature-card">
      <div class="feature-icon">🌿</div>
      <div class="feature-title">Curated Plant Database</div>
      <div class="feature-desc">~250 Florida native species • Plants Annie actually sells • Enough variety for real designs</div>
    </div>

    <div class="feature-card">
      <div class="feature-icon">🌱</div>
      <div class="feature-title">Plant Intelligence</div>
      <div class="feature-desc">Growth data • Spacing requirements • Sun/water needs • Native status • Zone compatibility</div>
    </div>

    <div class="feature-card">
      <div class="feature-icon">💧</div>
      <div class="feature-title">Local Conditions</div>
      <div class="feature-desc">Florida soil types • Rainfall patterns • Hardiness zones • Regional climate data</div>
    </div>
  </div>

  <div style="margin-top: 2.5rem; text-align: center; color: var(--accent-primary); font-weight: 600; font-size: 1rem;">
    Focus on what Annie needs for her customers, not comprehensive coverage
  </div>
</section>

<!-- Slide 6b: Phase 1 - Core Features -->
<section class="slide" data-index="6b">
  <div class="slide-header">
    <h1 class="slide-title">Phase 1: Core Features</h1>
    <div class="phase-subtitle">Illustrator plugin, not web app</div>
  </div>

  <div class="feature-grid" style="margin-top: 2rem;">
    <div class="feature-card">
      <div class="feature-icon">🎨</div>
      <div class="feature-title">GIS Import Button</div>
      <div class="feature-desc">Type address → parcel + aerial imagery appears in Illustrator • Scaled correctly • Ready to design</div>
    </div>

    <div class="feature-card">
      <div class="feature-icon">🪴</div>
      <div class="feature-title">Plant Picker Panel</div>
      <div class="feature-desc">Browse/filter 250 plants • Drag & drop placement • Smart filters (sun, water, native status)</div>
    </div>

    <div class="feature-card">
      <div class="feature-icon">📐</div>
      <div class="feature-title">Basic Layout Tools</div>
      <div class="feature-desc">Grid placement • Along-path planting • Simple area fills • Spacing helpers</div>
    </div>

    <div class="feature-card">
      <div class="feature-icon">📋</div>
      <div class="feature-title">Plant Schedule Export</div>
      <div class="feature-desc">One-click BOM generation • Counts by species • PDF export • Ready for nursery orders</div>
    </div>

    <div class="feature-card">
      <div class="feature-icon">✓</div>
      <div class="feature-title">Basic Validation</div>
      <div class="feature-desc">Spacing warnings • Overlap detection • Simple growth preview</div>
    </div>

    <div class="feature-card">
      <div class="feature-icon">🔄</div>
      <div class="feature-title">Plant Data Sync</div>
      <div class="feature-desc">Offline-first • Background updates • Cached for speed</div>
    </div>
  </div>

  <div style="margin-top: 2.5rem; text-align: center; color: var(--accent-primary); font-weight: 600; font-size: 1rem;">
    Augment Annie's existing Illustrator workflow, don't replace it
  </div>
</section>

<!-- Slide 6c: Phase 1 - NPR Preview -->
<section class="slide" data-index="6c">
  <div class="slide-header">
    <h1 class="slide-title">Phase 1: Hand-Drawn 2.5D Preview</h1>
    <div class="phase-subtitle">The "wow factor" - artist's sketch aesthetic</div>
  </div>

  <div class="two-column" style="margin-top: 2rem; gap: 3rem;">
    <div class="left-column">
      <h3 style="color: var(--accent-primary); margin-bottom: 1.5rem;">The Vision</h3>
      <p style="font-size: 1.05rem; line-height: 1.7; margin-bottom: 1.5rem;">
        Walk through the design in 3D with a <span class="highlight">hand-drawn sketch aesthetic</span> -
        like an architect's illustration come to life.
      </p>

      <ul class="bullet-list" style="font-size: 0.95rem;">
        <li><span class="highlight">Sprite-based plants</span> - Simple "cardboard cutout" style</li>
        <li><span class="highlight">Procedural pencil shaders</span> - GLSL sketch effects</li>
        <li><span class="highlight">Basic terrain</span> - Flat or simple elevation</li>
        <li><span class="highlight">First-person walk</span> - Explore the design</li>
      </ul>

      <p style="margin-top: 1.5rem; color: var(--text-secondary); font-size: 0.9rem; font-style: italic;">
        Note: This is optional for Phase 1. If Annie's team values the 2D tools more, we focus there first.
      </p>
    </div>

    <div class="right-column" style="background: rgba(52, 211, 153, 0.05); border: 1px solid var(--accent-primary); border-radius: 12px; padding: 1.5rem; display: flex; flex-direction: column; justify-content: center; align-items: center;">
      <h4 style="color: var(--accent-primary); margin-bottom: 1rem;">Live Shader Demo</h4>
      <div style="position: relative; width: 100%; aspect-ratio: 1; max-width: 400px; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
        <canvas id="nprShaderCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
      </div>
      <p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-top: 1rem;">
        <em>Procedural colored pencil sketch rendering</em>
      </p>
    </div>
  </div>

  <div style="margin-top: 2.5rem; padding: 1.5rem; background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; border-radius: 8px;">
    <p style="font-size: 0.95rem; line-height: 1.6; margin: 0;">
      <strong style="color: #ffc107;">Why this aesthetic?</strong>
      Differentiates from competitors' clinical 3D renderings. Aligns with landscape architecture presentation style.
      Performant enough for real-time on modest hardware. Makes designs feel artistic, not robotic.
    </p>
  </div>
</section>

<style>
.two-column {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
}

.phase-subtitle {
  font-size: 1.1rem;
  color: var(--text-secondary);
  margin-top: 0.5rem;
  font-weight: 400;
}
</style>

<script>
// Initialize NPR shader demo when slide is visible
let shaderInitialized = false;
function initShader() {
  if (shaderInitialized) {
    console.log('Shader already initialized, skipping');
    return;
  }

  const canvas = document.getElementById('nprShaderCanvas');
  if (!canvas) {
    console.error('Canvas not found!');
    return;
  }
  console.log('Initializing shader on canvas:', canvas);
  shaderInitialized = true;

  const gl = canvas.getContext('webgl2');
  if (!gl) {
    console.error('WebGL 2.0 not supported - falling back to WebGL 1.0');
    const gl1 = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl1) {
      console.error('WebGL not supported at all');
      canvas.getContext('2d').fillText('WebGL not supported', 50, 50);
      return;
    }
    console.error('This shader requires WebGL 2.0');
    return;
  }
  console.log('Using WebGL 2.0');

  // Set canvas size to match display size
  const rect = canvas.getBoundingClientRect();
  const size = Math.min(rect.width, rect.height) || 512;
  canvas.width = size;
  canvas.height = size;

  console.log('Canvas size:', canvas.width, 'x', canvas.height);

  // Vertex shader (standard quad) - WebGL 2.0 / GLSL ES 3.00
  const vertexShaderSource = `#version 300 es
in vec2 position;
void main() {
  gl_Position = vec4(position, 0.0, 1.0);
}
`;

  // Fragment shader loaded from external file
  // IMPORTANT: No whitespace before #version directive
  const fragmentShaderSource = `#version 300 es
precision highp float;
uniform vec2 iResolution;
uniform float iTime;

out vec4 fragColor;

// Common helper functions from common.glsl

// Hexagon vertices (from common.glsl)
vec2[6] vID = vec2[6](vec2(-.5, -2./6.)/vec2(.5, 1), vec2(-.5, 2./6.)/vec2(.5, 1), vec2(0, 2./3.)/vec2(.5, 1),
                      vec2(.5, 2./6.)/vec2(.5, 1), vec2(.5, -2./6.)/vec2(.5, 1), vec2(0, -2./3.)/vec2(.5, 1));

// Standard 2D rotation formula.
mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }

// IQ's vec2 to float hash.
float hash21(vec2 p){
    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831589))*43758.5453);
}

// Compact, self-contained version of IQ's 2D value noise function.
float n2D(vec2 p){
    const vec2 s = vec2(1, 113);
    vec2 ip = floor(p); p -= ip;
    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);
    p = p*p*(3. - 2.*p);
    h = fract(sin(mod(h, 6.2831589))*43758.5453);
    h.xy = mix(h.xy, h.zw, p.y);
    return mix(h.x, h.y, p.x);
}

// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.
float fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }

// This will draw a box (no caps) of width "ew" from point "a "to "b".
float lBox(vec2 p, vec2 a, vec2 b, float ew){
    float ang = atan(b.y - a.y, b.x - a.x);
    p = rot2(ang)*(p - mix(a, b, .5));
   vec2 l = vec2(length(b - a), ew);
   vec2 d = abs(p) - (l + ew)/2.;
   return min(max(d.x, d.y), 0.) + length(max(d, 0.));
}

// IQ's distance to a regular polygon - takes array like ShaderToy
float sdPoly4(in vec2 p, in vec2[4] v){
    float d = dot(p - v[0], p - v[0]);
    float s = 1.0;

    int j = 3;
    for(int i = 0; i < 4; i++){
        vec2 e = v[j] - v[i];
        vec2 w = p - v[i];
        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1.);
        d = min(d, dot(b,b));

        bvec3 cond = bvec3(p.y >= v[i].y, p.y < v[j].y, e.x*w.y > e.y*w.x);
        if(all(cond) || all(not(cond))) s *= -1.0;
        j = i;
    }
    return s*sqrt(d);
}

// Signed distance to a regular hexagon
float sdHexagon(in vec2 p, in float r){
    const vec3 k = vec3(-.8660254, .5, .57735);
    p = abs(p);
    p -= 2.*min(dot(k.xy, p), 0.)*k.xy;
    return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);
}

vec3 pencil(vec3 col, vec2 p){
    vec2 q = p*4.;
    const vec2 sc = vec2(1, 12);
    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;
    q *= rot2(-3.14159/2.5);
    col = min(col, 1.);
    float gr = (dot(col, vec3(.299, .587, .114)));
    float ns = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);
    q *= rot2(3.14159/2.);
    float ns2 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);
    q *= rot2(-3.14159/5.);
    float ns3 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);
    const float contrast = 1.;
    ns = (.5 + (gr - (max(max(ns, ns2), ns3)))*contrast);
    return vec3(clamp(ns, 0., 1.));
}

// Main cube-circle shader (from ShaderToy)
/*
	
	Cube Circle Sketch
	------------------

	I see a lot of really classy geometric styled pencil drawings on 
    the internet by various mathematical artists -- The effort that 
    goes into some of them is really impressive. Reproducing them in 
    code form is kind of cheating, but it's a little hard to resist. :)

	This particular arrangement is pretty common and something I've 
    seen many times in various forms, but most tend to be based off of 
    the works of mathematical artist Regolo Bizzi -- His Escheresque
    geometric designs are everywhere, but if you've never chanced upon 
    one of them, I've provided a link below. A lot of love and effort 
    would have gone into the original sketch, but the effort that went
    into the code version was far less impressive: Render 12 hexagons 
    on the border of a circle, orient them a bit (by PI/6), then shade 
    the faces. 
    
    There's some extra code to give it that tech drawing feel, fake 
    lighting and a mediocre sketch algorithm included, but that's it.

	Anyway, I was more interested in producing a halfway passable look
	in order to render more interesting patterns. Suggestions for 
	simple improvements are always welcome. :)



    // Links.

    // You can find some of Regolo Bizzi's work at the following:
    http://impossible-world.blogspot.com/2014/10/new-images-by-regolo-bizzi.html
    https://www.behance.net/regolo

*/


// Cube subdivision lines. Interesting, but a bit much, I think. :)
//#define SUBDIV_LINES 

// Greyscale sketch -- Sans color.
//#define GREYSCALE

// Blinking lights: It was an attempt to animate the sketch in a believable
// way... This isn't it. :D
//#define BLINKING_LIGHTS


void mainImage(out vec4 fragColor, in vec2 fragCoord){

    // Aspect correct screen coordinates.
	vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;
    
    // Scaling and translation.
    const float gSc = 1.;
    
    // Smoothing factor.
    float sf = gSc/iResolution.y;
    
    // Rotation speed -- Rotation seemed like a good idea at the time, but
    // I decided against it. :)
    float rT = 0.;//sin(-iTime/6.*3.)/12.;

    // Scaling and rotation.
    vec2 p = rot2(rT)*uv*gSc;
    
    // Distance field holders for the cubes, lines and the previous
    // cube (used for CSG related to overlap).
    float d = 1e5, ln = 1e5, prevD = 1e5; 
    
    // Edge width. 
    const float ew = .0025;
    
   
    // The cubes are rendered along the sides of a dodecahedron. These are just some standard
    // measurements to help place the cubes in the correct positions.
    //
    const float cR = .3; // Larger circle radius.
    const float cAp = cR*cos(6.2831/24.); // Apothem.
    const float sL = cR*acos(6.2831/24.)/2.; // Side length, which will relate to the hexagon scale.
    
    
        // The offset vertex information.
    // Hexagon vertices with scaling to enable rendering back in normal space. 
    vec2 hSc = sL*vec2(.5, .8660254);
    vec2[6] svV = vec2[6](vID[0]*hSc, vID[1]*hSc, vID[2]*hSc, vID[3]*hSc, vID[4]*hSc, vID[5]*hSc);

   
    // Coordinate perturbation. There's small rigid one to enhance the hand-drawn look, and
    // a larger animated one to wave the paper around a bit.
    vec2 offs = vec2(fbm(p*16.), fbm(p*16. + .35));
    vec2 offs2 = vec2(fbm(p*1. + iTime/4.), fbm(p*1. + .5 + iTime/4.));
    const float oFct = .007;
    const float oFct2 = .05;
    p -= (offs - .5)*oFct;
    p -= (offs2 - .5)*oFct2;
    
 
    
    
    float lnL = -cR - sL*.75; // Line length.
    float a0 = 6.2831/24.; // Initial reference angle.
    float dA = 6.2831/12.; // One twelth revolution.
    float inR =  cR - sL/2.*.8660254; // Inner radius. 
    
    
    // Some distance field holders.
    float gHex = 1e5, gD = 1e5, qLn = 1e5, dSh = 1e5;
    // Z buffer, for shadows.
    float zBuf = 0.;
    
    
    
    // Fake lighting.
    vec3 lp = vec3(-.75, 3, -1.5);
    vec3 ld = normalize(lp - vec3(uv, 0)); 
    ld.xy = rot2(rT)*ld.xy;
    
    
    // Initialize the background.
    vec3 col = vec3(.95, .975, 1);
    
    
    vec2 q; 
    
    // Apply some graph lines.
    float dim = 9.; // For the lines to match up: dim = 9./(cR*3.);
    q = p;//uv*gSc - (offs - .5)*oFct  - (offs2 - .5)*oFct2;//uv*gSc - (offs - .5)*oFct;//p;//
    q = abs(mod(q, 1./dim) - .5/dim);
    float ln3 = abs(max(q.x, q.y) - .5/dim);
    col = mix(col, vec3(.35, .65, 1), (1. - smoothstep(0., sf*2., ln3))*.8);
    dim *= 2.;
    q = p;//uv*gSc - (offs - .5)*oFct  - (offs2 - .5)*oFct2;//uv*gSc - (offs - .5)*oFct;//p;//
    q = abs(mod(q, 1./dim) - .5/dim);
    ln3 = max(abs(max(q.x, q.y) - .5/dim), -ln3);
    col = mix(col, vec3(.35, .65, 1), (1. - smoothstep(0., sf*2., ln3))*.65);
    
    // Applying light and a bit of noise to the background.
    col *= clamp(dot(normalize(vec3(p, -1.5)), ld), 0., 1.)*.2 + .8;
    col *= fbm(p*8.)*.1 + .9;
    
    
    // Produce and render the 12 cubes. This is pretty standard stuff -- Position
    // the cubes and render three rhomboids for the cube faces.
    
    // Cube face normals.
    vec3[3] n = vec3[3](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, -1));
       

    // Iterate through all 12 cubes -- Some will note that you could apply polar
    // coordinates and cut this right down to two iterations, which would definitely
    // be faster. However, the example isn't too taxing on the system, and the
    // brute force method simplifies the code a bit... Having said that, I might
    // cave in an update this later. :)
    //
    for(int i = 0; i<12; i++){
        
        q = p;
        
        // Grey lines point to point lines.
        vec2 a, b, nA;
        a =  rot2(a0 + dA*float(i))*vec2(0, inR);
        b =  rot2(a0 + dA*float(i + 3))*vec2(0, inR);
        nA = normalize(b - a)*sL*1.6;
        ln = min(ln, lBox(q, a - nA, b + nA, 0.));
        
        
        // Hexagons.
        vec2 hCtr = rot2(6.2831/12.*float(11 - i))*vec2(0, cR); // Hexagon center.
        q -= hCtr; // Move to the border.
        q = rot2(-6.2831/12.*float(11 - i))*q; // Rotate in situ.
        //q = rot2(iTime/3.)*q; // Rotate individual hexagons.
        float dH = sdHexagon(q, sL/2.); // Hexagon distance field.
        d = dH;
        
        // Hexagon or cube shadows.
        vec2 qSh = p + ld.xy*.03;
        qSh -= hCtr;
        qSh = rot2(-6.2831/12.*float(11 - i))*qSh;
        dSh = sdHexagon(qSh, sL/2.);
        
        // All hexagons.
        gHex = min(gHex, d);
        
        // Grey hexagon circle outlines.
        ln = min(ln, abs(length(q) - sL/2./.8660254));
        
        // Cutting out the previous hexagon to avoid overlap. A Z-buffer would
        // also work, and might be cleaner, but it's done now. :)
        d = max(d, -(prevD - ew/3.));
        
        prevD = d; 
        
        // Shadow and shadow buffer -- Needs fixing, but it'll do for now.
        col = mix(col, mix(vec3(0), col, zBuf), (1. - smoothstep(0., sf*5., dSh - ew/2.))*.35);
        zBuf = mix(zBuf, 1., (1. - smoothstep(0., sf*5., dSh - ew/2.))); 
  
        // Combination of all objects... It was used to rotate things in combination with
        // the sketch algorithm, but I decided against it.
        gD = min(gD, min(min(ln, d), dSh));
        
        // Rendering the hexagon base -- Not entirely necessary, but it enhance the edges.
        col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., d - ew/2.))*.35); // Fake AO.
        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d - ew/2.))*.8);
        //col = mix(col, vec3(1), (1. - smoothstep(0., sf, d + ew - ew/2.)));
          
          
             
        // Iterate through the three cube faces.
        for(int j = 0; j<6; j+=2){
        
            // Constructing the edge midpoints and normals at those
            // points for both the string and corresponding shadows.
            vec2[4] v = vec2[4](svV[(j + 1)%6].yx, svV[(j + 2)%6].yx, svV[(j + 3)%6].yx, vec2(0));

            // Quad center and local quad ID.
            vec2 qCtr = (v[0] + v[1] + v[2] + v[3])/4.;
            vec2 qID = hCtr + qCtr;
            
            // Face quad.
            float quad = max(sdPoly4(q, v), d);
            
            // Accumulated quad field.
            gD = min(gD, quad);
            
            // Spectrum or rainbow colors.
            vec3 rnbCol = .6 + .4*cos(6.2831*float(i)/12. + vec3(0, 1, 2)*1.5 + 3.14159/6.);
            
            #ifdef BLINKING_LIGHTS
            float rndI = hash21(hCtr); rndI = cos(rndI*6.2831 + iTime/1.25 + .5);
            rndI = smoothstep(.9, .95, sin(rndI*6.2831 + iTime*3.)*.5 + .5);
            
            vec3 rCol = vec3(.55) + float(i%3)/12.;//vec3(hash21(hCtr + .6)*.35 + .5);
            rCol = mix(rCol, dot(rCol, vec3(.299, .587, .114))*vec3(4, 1, .5), rndI);
            rCol = mix(rCol, rCol.xzy, sin(hash21(hCtr + .44)*6.2831 + iTime)*.35 + .35);
            
            // Alternative.
            //vec3 rCol = rnbCol;
            //rCol = mix(rCol, rnbCol*1.5, rndI);
            #else
            vec3 rCol = rnbCol;
            #endif
            
  
            // Face normal.
            vec3 sn = n[j/2];
            // Rotate the face normals about the XY axis -- Since this isn't 3D, we
            // need to fake it.
            sn.xy = rot2(6.2831/12.*float(11 - i))*sn.xy;
             
            // Using the quad distance field for a bit of shading. In this case, it
            // gives the cubes a subtle faux ambient occulsion feel.
            float sh = clamp(.35 - quad/.03, 0., 1.)*.3 + .7;
            // Standard diffuse lighting.
            float dif = max(dot(ld, sn), 0.);
            // Lit face color.
            rCol = rCol*(dif + .5)*sh;
            
            // Render the face quad.
            col = mix(col, rCol*.5, (1. - smoothstep(0., sf, quad)));
            col = mix(col, vec3(rCol), (1. - smoothstep(0., sf, quad + ew)));
            
            #ifdef SUBDIV_LINES
            // Quad lines -- Not used.
            
            qLn = lBox(q, mix(v[0], v[1], .5), mix(v[2], v[3], .5), .0);
            qLn = min(qLn, lBox(q, mix(v[1], v[2], .5), mix(v[3], v[0], .5), .0));
            /*         
            qLn = lBox(q, mix(v[0], v[1], .333), mix(v[2], v[3], .666), .0);
            qLn = min(qLn, lBox(q, mix(v[1], v[2], .333), mix(v[3], v[0], .666), .0));
            qLn = min(qLn, lBox(q, mix(v[0], v[1], .666), mix(v[2], v[3], .333), .0));
            qLn = min(qLn, lBox(q, mix(v[1], v[2], .666), mix(v[3], v[0], .333), .0));
            */
            qLn = max(qLn, (prevD - ew/3.));
            
            vec3 svCol = col;
            col = mix(col, col*1.35, (1. - smoothstep(0., sf*3., qLn - .003)));
            col = mix(col, svCol*.65, (1. - smoothstep(0., sf*2., qLn - .001)));
            #endif
        }
        
         
    }
    

    // Faking the ruled guide lines. We'll make them more pronounced outside the colored
    // cubes and faint over the top.
    float lAlpha = mix(.25, .125, 1. - smoothstep(0., sf*2., gHex));
    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., ln - .001*fbm(p*32. + .5)))*lAlpha);
    // IQ's suggestion to let a trace amount of the graph paper pattern show through.
    // The graph paper was a later addition, so I'd forgotten to include it.
    col = mix(col, vec3(.35, .65, 1)/4., (1. - smoothstep(0., sf*2., max(gHex, ln3)))*.25);
    
    
 
    // Subtle pencil overlay... It's cheap and definitely not production worthy,
    // but it works well enough for the purpose of the example. The idea is based
    // off of one of Flockaroo's examples.
    q = p*8.;//mix(p*10., uv*gSc*10. - (offs - .5)*oFct  - (offs2 - .5)*oFct2, smoothstep(0., sf, gD));
    vec3 colP = pencil(col, q*iResolution.y/450.);
    #ifdef GREYSCALE
    // Just the pencil sketch. The last factor ranges from zero to one and 
    // determines the sketchiness of the rendering... Pun intended. :D
    col = mix(dot(col, vec3(.299, .587, .114))*vec3(1), colP, .6);
    #else
    col = mix(col, 1. - exp(-(col*2.)*(colP + .25)), .85); 
    #endif
    //col = mix(col, colP, .5);
    //col = mix(min(col, colP), max(col, colP), .5); 
   
  
     // Cheap paper grain... Also barely worth the effort. :)
    vec2 pp = q;//floor(q*1024.);
    vec3 rn3 = vec3(hash21(pp), hash21(pp + 2.37), hash21(pp + 4.83));
    vec3 pg = .8 + (rn3.xyz*.35 + rn3.xxx*.65)*.4;
    col *= min(pg, 1.); 
    
    
    // Rough gamma correction and output to screen.
    fragColor = vec4(sqrt(max(col, 0.)), 1);
}

void main() {
    mainImage(fragColor, gl_FragCoord.xy);
}
`;

  // Compile shaders
  function compileShader(source, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
  const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

  if (!vertexShader || !fragmentShader) return;

  // Link program
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    return;
  }

  gl.useProgram(program);

  // Setup geometry (fullscreen quad)
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
     1,  1
  ]), gl.STATIC_DRAW);

  const positionLocation = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  // Set viewport
  gl.viewport(0, 0, canvas.width, canvas.height);
  console.log('Viewport set to:', canvas.width, 'x', canvas.height);

  // Get uniform locations (MUST be done AFTER useProgram and BEFORE first render)
  // Note: Must ensure program is current before getting locations
  gl.useProgram(program);

  const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
  const iTimeLocation = gl.getUniformLocation(program, 'iTime');

  console.log('Uniform locations:', {
    iResolution: iResolutionLocation,
    iTime: iTimeLocation
  });

  // Verify uniforms were found (null or -1 means not found)
  if (!iResolutionLocation || iResolutionLocation === -1) {
    console.error('Could not find uniform: iResolution');
  }
  if (!iTimeLocation || iTimeLocation === -1) {
    console.error('Could not find uniform: iTime');
  }

  // Render loop
  let startTime = Date.now();
  function render() {
    const currentTime = (Date.now() - startTime) / 1000.0;

    // Only set uniforms if locations are valid
    if (iResolutionLocation && iResolutionLocation !== -1) {
      gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
    }
    if (iTimeLocation && iTimeLocation !== -1) {
      gl.uniform1f(iTimeLocation, currentTime);
    }

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
  }

  console.log('Starting render loop');
  render();
}

// Try to initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initShader);
} else {
  initShader();
}

// Also try again on window load
window.addEventListener('load', function() {
  const canvas = document.getElementById('nprShaderCanvas');
  if (canvas && !canvas.getContext('webgl')) {
    initShader();
  }
});
</script>

<!-- Slide 7: Tech Approach -->
    <section class="slide" data-index="7">
      <div class="slide-header">
        <h1 class="slide-title">Built for Scale</h1>
      </div>
      <div class="feature-grid">
        <div class="feature-card">
          <div class="feature-icon">⚡</div>
          <div class="feature-title">Babylon.js Core</div>
          <div class="feature-desc">Unified 2D/3D rendering with orthographic camera</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">🗺️</div>
          <div class="feature-title">GIS Integration</div>
          <div class="feature-desc">GeoTIFFs, KMLs, parcel APIs, elevation data</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">📱</div>
          <div class="feature-title">Progressive Web App</div>
          <div class="feature-desc">Works everywhere, offline-capable</div>
        </div>
      </div>
    </section>

<!-- Slide 8: Business Model -->
    <section class="slide" data-index="8">
      <div class="slide-header">
        <h1 class="slide-title">Multiple Revenue Streams</h1>
      </div>
      <ul class="bullet-list">
        <li><span class="highlight">Freemium SaaS:</span> Free tier → Pro at $20-50/month</li>
        <li><span class="highlight">White Label:</span> Branded exports for nursery partners</li>
        <li><span class="highlight">Affiliate Revenue:</span> Integration with suppliers (Home Depot, local nurseries)</li>
        <li><span class="highlight">Future Expansion:</span> Full proposals with cost estimation</li>
      </ul>
    </section>

<section class="slide" data-index="9">
      <div class="slide-header">
        <h1 class="slide-title">Perfect Timing</h1>
      </div>
      <div class="feature-grid">
        <div class="feature-card">
          <div class="feature-icon">🏡</div>
          <div class="feature-title">Outdoor Living Boom</div>
          <div class="feature-desc">Post-pandemic shift to home improvement</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">🌱</div>
          <div class="feature-title">Sustainability Push</div>
          <div class="feature-desc">Regulations favor native plants & water conservation</div>
        </div>
        <div class="feature-card">
          <div class="feature-icon">☁️</div>
          <div class="feature-title">Cloud + AI Ready</div>
          <div class="feature-desc">Small teams can now build magic quickly</div>
        </div>
      </div>
    </section>
<section class="slide" data-index="10">
      <div class="slide-header">
        <h1 class="slide-title">The Perfect Team</h1>
      </div>
      <div class="team-grid">
        <div class="team-member">
          <div class="member-avatar">🗺️</div>
          <div class="member-name">Geoff</div>
          <div class="member-role">Technical Lead<br>GIS + CAD + Full-Stack Engineering</div>
        </div>
        <div class="team-member">
          <div class="member-avatar">🌺</div>
          <div class="member-name">Annie</div>
          <div class="member-role">Design & Domain Expert<br>Nursery owner + customer validation</div>
        </div>
      </div>
      <p style="text-align: center; margin-top: 2rem; color: var(--text-secondary);">
        Technical expertise • Domain knowledge • Customer access
      </p>
    </section>
<!-- Slide 11: Traction -->
    <section class="slide" data-index="11">
      <div class="slide-header">
        <h1 class="slide-title">Path to Launch</h1>
      </div>
      <ul class="bullet-list">
        <li><span class="highlight">Completed:</span> Full technical architecture designed & prototyped</li>
        <li><span class="highlight">Working now:</span> GIS pipeline processing real parcels • NPR shaders rendering</li>
        <li><span class="highlight">In progress:</span> Illustrator UXP plugin with plant layout algorithms</li>
        <li><span class="highlight">Next 3 months:</span> Annie pilot program with nursery customers</li>
        <li><span class="highlight">Unfair advantage:</span> Solved the hard technical problems that keep competitors stuck</li>
      </ul>
    </section>

<!-- Slide 12: Vision -->
    <section class="slide" data-index="12">
      <div class="slide-header">
        <h1 class="slide-title">The Vision</h1>
      </div>
      <div class="slide-content">
        <p style="font-size: 1.4rem; line-height: 1.8; margin-bottom: 2rem;">
          Flora will be the <span class="highlight">operating system for sustainable landscape design</span>.
        </p>
        <p style="color: var(--text-secondary); margin-bottom: 2rem;">
          By uniting instant site data, ecological intelligence, and delightful design, we'll enable small businesses and homeowners to create outdoor spaces that are beautiful, resilient, and ecologically sound.
        </p>
        <p style="color: var(--text-secondary);">
          Long-term: From plant lists to full proposals. From individual yards to urban-scale ecological planning.
        </p>
      </div>
    </section>

<!-- Slide 13: Call to Action -->
    <section class="slide title-slide" data-index="13">
      <h1 class="main-title">Let's Build This</h1>
      <h2 class="main-subtitle">The foundation is built. Time to launch.</h2>
      <div style="margin-top: 3rem;">
        <ul class="bullet-list" style="text-align: left; display: inline-block;">
          <li><span class="highlight">Proven technology stack</span> – Illustrator plugin + GIS pipeline working</li>
          <li><span class="highlight">Domain expertise</span> – Annie's nursery customers ready to pilot</li>
          <li><span class="highlight">Technical execution</span> – Complex rendering and geometry algorithms solved</li>
          <li><span class="highlight">Clear path to revenue</span> – SaaS + nursery partnerships</li>
        </ul>
      </div>
    </section>

    </div>

    <div class="controls">
        <button id="prev" aria-label="Previous slide">←</button>
        <span id="counter">1 / 16</span>
        <button id="next" aria-label="Next slide">→</button>
    </div>

    <div class="help">
        Use ← / → arrows • <kbd>F</kbd> fullscreen • <kbd>P</kbd> print • <kbd>Space</kbd> next
    </div>

    <div class="mobile-swipe-hint">
        Swipe left/right to navigate
    </div>

    <!-- Code highlighting JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>

    <!-- Leaflet JavaScript for GIS demo -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- PixiJS for interactive math demos -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            hljs.highlightAll();

            // Sanity check for D3 and fc libraries
            console.log("✅ D3 loaded?", typeof d3);
            console.log("✅ fc loaded?", typeof fc);

            if (typeof d3 !== 'undefined' && typeof fc !== 'undefined') {
                console.log("✅ D3 version:", d3.version);
                console.log("✅ fc.layoutLabel exists?", typeof fc.layoutLabel);
            } else {
                console.error("❌ D3 or fc libraries failed to load!");
            }
        });

        // Helper function to expand SVG viewBox to prevent text cutoff
        function expandViewBox(svg, pad = 20) {
            console.log("📐 expandViewBox called with padding:", pad);
            const node = svg.node ? svg.node() : svg;
            const box = node.getBBox();
            const oldViewBox = node.getAttribute("viewBox");
            const newViewBox = [
                box.x - pad,
                box.y - pad,
                box.width + 2 * pad,
                box.height + 2 * pad
            ].join(" ");

            console.log("   Old viewBox:", oldViewBox);
            console.log("   New viewBox:", newViewBox);

            if (svg.attr) {
                svg.attr("viewBox", newViewBox);
            } else {
                node.setAttribute("viewBox", newViewBox);
            }
        }

        // Helper function to wait for libraries to load
        function waitForLibraries(callback, maxRetries = 20) {
            let retries = 0;
            const checkInterval = setInterval(() => {
                retries++;
                if (window.d3 && window.fc) {
                    console.log("✅ D3 and fc libraries loaded");
                    clearInterval(checkInterval);
                    callback();
                } else if (retries >= maxRetries) {
                    console.warn("⚠️ Timeout waiting for D3/fc libraries after", retries, "attempts");
                    clearInterval(checkInterval);
                } else {
                    console.log("⏳ Waiting for D3/fc libraries... attempt", retries);
                }
            }, 100);
        }

        // Helper function to fix SVG text layout and prevent overlap
        function fixSVGLayout(svgElement) {
            console.log("🔧 fixSVGLayout called for SVG element");

            if (!window.d3 || !window.fc) {
                console.warn("⚠️ D3 or fc libraries not loaded yet, will retry...");
                waitForLibraries(() => {
                    console.log("🔄 Retrying fixSVGLayout after libraries loaded");
                    fixSVGLayout(svgElement);
                });
                return;
            }

            const svg = d3.select(svgElement);
            console.log("   SVG selected with D3");

            // Expand viewBox to prevent edge clipping
            expandViewBox(svg, 25);

            // Optional: Apply label layout if there are many text elements
            const textElements = svg.selectAll("text");
            console.log('   Found ' + textElements.size() + ' text elements');

            if (textElements.size() > 4) {
                console.log("   Applying d3fc label layout for", textElements.size(), "text elements");
                // For complex layouts with many labels, use d3fc-label-layout
                try {
                    const labels = textElements.nodes();
                    const layout = fc.layoutLabel()
                        .size(d => {
                            const box = d.getBBox();
                            return [box.width, box.height];
                        })
                        .position(d => {
                            const x = parseFloat(d.getAttribute("x") || 0);
                            const y = parseFloat(d.getAttribute("y") || 0);
                            return [x, y];
                        });

                    svg.datum(labels).call(layout);
                    console.log("   ✅ Label layout applied successfully");
                } catch (e) {
                    console.warn("   ❌ Label layout failed:", e);
                }
            } else {
                console.log("   Skipping label layout (not enough text elements)");
            }
        }

        // Helper function to compute safe SVG bounds
        function computeSvgBounds(svgNode) {
            const svg = d3.select(svgNode);
            const vbAttr = svg.attr("viewBox");
            if (vbAttr) {
                const nums = vbAttr.trim().split(/\s+/).map(Number);
                if (nums.length === 4 && nums.every(Number.isFinite)) {
                    const [vx, vy, vw, vh] = nums;
                    if (vw > 0 && vh > 0) return { x: vx, y: vy, width: vw, height: vh };
                }
            }
            // fallback: bbox + padding, and set a sane viewBox
            const b = svgNode.getBBox();
            const bounds = { x: b.x - 16, y: b.y - 16, width: b.width + 32, height: b.height + 32 };
            svg.attr("viewBox", bounds.x + " " + bounds.y + " " + bounds.width + " " + bounds.height);
            return bounds;
        }

        // Move existing <text> elements with d3fc (no new labels are created)
        window.applyLabelLayout = function applyLabelLayout(svgNode, { anneal = false } = {}) {
            if (!window.d3 || !window.fc) {
                console.warn("applyLabelLayout: d3/fc not present");
                return;
            }

            console.log('🏷️ Applying label layout (reuse existing labels)');
            const svg = d3.select(svgNode);
            const textsSel = svg.selectAll("text");
            const textNodes = textsSel.nodes();

            if (textNodes.length < 2) {
                console.log('   Skipping layout (less than 2 text elements)');
                return; // nothing to resolve
            }

            // normalize anchors to reduce surprises
            textsSel
                .attr("dominant-baseline", function () { return this.getAttribute("dominant-baseline") || "middle"; })
                .attr("text-anchor", function () { return this.getAttribute("text-anchor") || "middle"; });

            const bounds = computeSvgBounds(svgNode);
            console.log('   Using bounds:', bounds);

            // pick strategy
            const base = anneal ? fc.layoutAnnealing() : fc.layoutGreedy();
            const strategy = fc.layoutRemoveOverlaps(base.bounds(bounds));

            // NO component: we don't want new nodes rendered
            const noop = () => {};

            // layout that measures & reads current positions off each datum (the SVGTextElement)
            const layout = fc.layoutLabel(strategy)
                .size(function (d) {
                    const bb = d.getBBox();
                    return [bb.width + 8, bb.height + 6];  // padding around label boxes
                })
                .position(function (d) {
                    return [ +d.getAttribute("x") || 0, +d.getAttribute("y") || 0 ];
                })
                .component(noop);

            // bind nodes as data and run layout
            svg.datum(textNodes).call(layout);

            // now bind those datums to the text selection
            textsSel.data(textNodes);

            // write solved positions back; keep old value as fallback
            textsSel
                .attr("x", function (d) { return (d && Number.isFinite(d.x)) ? d.x : +this.getAttribute("x"); })
                .attr("y", function (d) { return (d && Number.isFinite(d.y)) ? d.y : +this.getAttribute("y"); });
            console.log('   ✅ Label layout applied to', textNodes.length, 'existing text elements (no new nodes created)');
        };

        // Move every <text> to the end of its parent so it paints on top
        function bringTextToFront(svgEl) {
            console.log('📤 Bringing text elements to front');
            const texts = svgEl.querySelectorAll('text');
            texts.forEach(t => t.parentNode.appendChild(t)); // append = top of paint order
            console.log('   ✅ Moved', texts.length, 'text elements to front');
        }

        // Ensure SVG has the filter definitions for labels
        function ensureLabelFilters(svgEl) {
            const NS = "http://www.w3.org/2000/svg";
            let defs = svgEl.querySelector("defs");
            if (!defs) {
                defs = document.createElementNS(NS, "defs");
                svgEl.insertBefore(defs, svgEl.firstChild);
            }

            if (!svgEl.querySelector("#label-shadow")) {
                const f = document.createElementNS(NS, "filter");
                f.setAttribute("id", "label-shadow");
                f.innerHTML = '<feDropShadow dx="0" dy=".7" stdDeviation="1.2" flood-color="#000" flood-opacity=".55"/>';
                defs.appendChild(f);
            }
            if (!svgEl.querySelector("#label-glow")) {
                const f = document.createElementNS(NS, "filter");
                f.setAttribute("id", "label-glow");
                f.setAttribute("x", "-20%");
                f.setAttribute("y", "-20%");
                f.setAttribute("width", "140%");
                f.setAttribute("height", "140%");
                f.innerHTML = '<feGaussianBlur in="SourceAlpha" stdDeviation="1.4" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>';
                defs.appendChild(f);
            }
        }

        // Apply styling filters to labels
        function styleLabels(svgEl, { use = "shadow" } = {}) {
            console.log('🎨 Applying', use, 'filter to text labels');
            ensureLabelFilters(svgEl);
            const texts = svgEl.querySelectorAll("text");
            texts.forEach(t => {
                t.setAttribute("filter", 'url(#label-' + use + ')');
            });
            console.log('   ✅ Applied', use, 'filter to', texts.length, 'text elements');
        }

        // Reduce the size of filled endpoint circles; leave stroked rings alone
        function shrinkEndpoints(svgEl, targetR = 5) {
            console.log('🔴 Shrinking endpoint bulbs to radius', targetR);
            let shrunkCount = 0;
            svgEl.querySelectorAll('circle').forEach(c => {
                const r0 = +c.getAttribute('r') || 0;
                const fill = (c.getAttribute('fill') || '').trim().toLowerCase();
                const hasFill = fill && fill !== 'none';
                // Heuristic: rings in your slides have fill="none", endpoints are filled
                if (hasFill && r0 > targetR) {
                    c.setAttribute('r', targetR);
                    shrunkCount++;
                }
            });
            console.log('   ✅ Shrunk', shrunkCount, 'filled circles from larger sizes to', targetR);
        }

        // Called after each slide's SVG is inserted (comprehensive enhancement pipeline)
        window.fixSVGLayoutAndLabels = function fixSVGLayoutAndLabels(svgEl) {
            console.log('🔧 fixSVGLayoutAndLabels called - running full enhancement pipeline');

            if (window.fixSVGLayout) {
                window.fixSVGLayout(svgEl);         // your viewBox pad step
            }
            if (window.applyLabelLayout) {
                window.applyLabelLayout(svgEl);     // space labels (greedy)
            }
            bringTextToFront(svgEl);                // labels above graphics
            styleLabels(svgEl, { use: "shadow" });  // halo + subtle shadow
            shrinkEndpoints(svgEl, 5);              // smaller bulbs globally

            console.log('   ✅ Enhancement pipeline completed');
        };

        // Auto-fix all SVGs when a slide is loaded
        window.addEventListener("slideLoaded", () => {
            console.log("📄 slideLoaded event received");
            const svgs = document.querySelectorAll("#slide-content svg");
            console.log('   Found ' + svgs.length + ' SVG(s) in slide content');

            if (svgs.length > 0) {
                // Wait for libraries to be ready before processing SVGs
                if (!window.d3 || !window.fc) {
                    console.log("⏳ Libraries not ready, waiting...");
                    waitForLibraries(() => {
                        svgs.forEach((svg, index) => {
                            console.log('   Processing SVG ' + (index + 1) + '/' + svgs.length);
                            fixSVGLayoutAndLabels(svg);
                        });
                    });
                } else {
                    svgs.forEach((svg, index) => {
                        console.log('   Processing SVG ' + (index + 1) + '/' + svgs.length);
                        fixSVGLayoutAndLabels(svg);
                    });
                }
            }
        });
    </script>

    <script>
// No embedded data needed for this presentation
console.log('Presentation loaded - no external data dependencies');


// This function contains all the logic for the aerial photography scheduling slide
// Shows why vector embedding matters for "time to optimal window" calculations

function initFlightPhotoWindow() {
  try {
    console.log("📸 Initializing Flight Photo Window demo...");

    // Get DOM elements
    const departureSlider = document.getElementById("departure-time");
    const durationSlider = document.getElementById("flight-duration");
    const timezonesSlider = document.getElementById("timezones");

    const departureValue = document.getElementById("departure-value");
    const durationValue = document.getElementById("duration-value");
    const timezoneValue = document.getElementById("timezone-value");

    const depClock = document.getElementById("departure-clock");
    const arrClock = document.getElementById("arrival-clock");
    const depHand = document.getElementById("dep-hand");
    const arrHand = document.getElementById("arr-hand");

    const vectorSpace = document.getElementById("vector-space");
    const depVector = document.getElementById("dep-vector");
    const arrVector = document.getElementById("arr-vector");
    const depPoint = document.getElementById("dep-point");
    const arrPoint = document.getElementById("arr-point");
    const depLabel = document.getElementById("dep-label");
    const arrLabel = document.getElementById("arr-label");

    const distanceArc = document.getElementById("distance-arc");
    const distanceLabel = document.getElementById("distance-label");

    // Time toggle button and labels
    const timeToggle = document.getElementById("time-toggle");
    const labelNorth = document.getElementById("label-north");
    const labelEast = document.getElementById("label-east");
    const labelSouth = document.getElementById("label-south");
    const labelWest = document.getElementById("label-west");
    let isMilitaryTime = true;

    const naiveDistance = document.getElementById("naive-distance");
    const vectorDistance = document.getElementById("vector-distance");
    const morningDistance = document.getElementById("morning-distance");
    const photoQuality = document.getElementById("photo-quality");

    const naiveResult = document.getElementById("naive-result");
    const vectorResult = document.getElementById("vector-result");
    const morningResult = document.getElementById("morning-result");
    const photoReady = document.getElementById("photo-ready");

    // Pedagogical elements
    const hintButton = document.getElementById("hint-button");
    const hintContent = document.getElementById("hint-content");
    const methodDifference = document.getElementById("method-difference");
    const differenceExplanation = document.getElementById(
      "difference-explanation"
    );
    const explanationText = document.getElementById("explanation-text");

    // Photo windows (in 24h format)
    const MORNING_START = 9; // 9 AM
    const MORNING_END = 11; // 11 AM
    const AFTERNOON_START = 14; // 2 PM
    const AFTERNOON_END = 16; // 4 PM

    // THE KEY FUNCTION: Embed time-of-day as 2D vector
    function embedTimeAsVector(hours) {
      // Convert to clock position:
      // - 0 hours (midnight) should be at top (angle = -π/2 in standard coords)
      // - Hours increase clockwise
      const theta = (2 * Math.PI * hours) / 24 - Math.PI / 2;
      return {
        x: Math.cos(theta),
        y: Math.sin(theta),
        angle: theta,
      };
    }

    // Compute circular distance between two times (in hours)
    function circularDistance(hours1, hours2) {
      const vec1 = embedTimeAsVector(hours1);
      const vec2 = embedTimeAsVector(hours2);

      // Dot product gives us cos(angle between)
      const dotProduct = vec1.x * vec2.x + vec1.y * vec2.y;
      const angleDistance = Math.acos(Math.max(-1, Math.min(1, dotProduct)));

      // Convert radians to hours
      return (angleDistance * 12) / Math.PI;
    }

    // NAIVE distance calculation (what most systems do wrong)
    function naiveTimeDistance(currentTime, targetWindow) {
      // Most flight planning software does this simple subtraction
      let distance = targetWindow - currentTime;

      // Handle negative by adding 24 (but this is where it goes wrong!)
      if (distance < 0) {
        distance += 24;
      }

      // This gives you "hours until next occurrence" but not shortest distance!
      return distance;
    }

    // Find OPTIMAL photo window - this is where embedding shines!
    function findOptimalWindow(arrivalTime) {
      // Check all windows and find the best one
      const windows = [
        { start: MORNING_START, end: MORNING_END, name: "Morning" },
        { start: AFTERNOON_START, end: AFTERNOON_END, name: "Afternoon" },
      ];

      let bestWindow = null;
      let shortestWait = 24;

      // Naive approach - find the CHRONOLOGICALLY NEXT window
      let naiveChoice = null;
      let naiveWait = 24;

      // First, try to find a window later today
      for (const window of windows) {
        const windowCenter = (window.start + window.end) / 2;

        if (windowCenter > arrivalTime) {
          const waitTime = windowCenter - arrivalTime;
          if (waitTime < naiveWait) {
            naiveWait = waitTime;
            naiveChoice = window;
          }
        }
      }

      // If no window found later today, pick the earliest tomorrow
      if (!naiveChoice) {
        // Morning comes first tomorrow
        naiveChoice = windows[0]; // Morning window
        naiveWait = (MORNING_START + MORNING_END) / 2 + 24 - arrivalTime;
      }

      // Vector embedding approach - finds TRUE shortest distance in either direction
      for (const window of windows) {
        const windowCenter = (window.start + window.end) / 2;
        const vectorDist = circularDistance(arrivalTime, windowCenter);

        if (vectorDist < shortestWait) {
          shortestWait = vectorDist;
          bestWindow = window;
        }
      }

      return {
        optimal: bestWindow,
        optimalWait: shortestWait,
        naive: naiveChoice,
        naiveWait: naiveWait,
        differentChoice: bestWindow.name !== naiveChoice.name,
      };
    }

    // Draw photo windows on clock
    function drawPhotoWindows(svg) {
      const windows = svg.querySelector(".photo-windows");
      windows.innerHTML = "";

      // Morning window arc
      const morningStart = (MORNING_START * 360) / 24 - 90;
      const morningEnd = (MORNING_END * 360) / 24 - 90;
      const morningArc = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      const morningPath = describeArc(100, 100, 80, morningStart, morningEnd);
      morningArc.setAttribute("d", morningPath);
      morningArc.setAttribute("fill", "none");
      morningArc.setAttribute("stroke", "var(--bb-gold)");
      morningArc.setAttribute("stroke-width", "8");
      morningArc.setAttribute("opacity", "0.4");
      windows.appendChild(morningArc);

      // Afternoon window arc
      const afternoonStart = (AFTERNOON_START * 360) / 24 - 90;
      const afternoonEnd = (AFTERNOON_END * 360) / 24 - 90;
      const afternoonArc = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      const afternoonPath = describeArc(
        100,
        100,
        80,
        afternoonStart,
        afternoonEnd
      );
      afternoonArc.setAttribute("d", afternoonPath);
      afternoonArc.setAttribute("fill", "none");
      afternoonArc.setAttribute("stroke", "var(--bb-info)");
      afternoonArc.setAttribute("stroke-width", "8");
      afternoonArc.setAttribute("opacity", "0.4");
      windows.appendChild(afternoonArc);
    }

    // Helper to create SVG arc path
    function describeArc(x, y, radius, startAngle, endAngle) {
      const start = polarToCartesian(x, y, radius, endAngle);
      const end = polarToCartesian(x, y, radius, startAngle);
      const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
      return [
        "M",
        start.x,
        start.y,
        "A",
        radius,
        radius,
        0,
        largeArcFlag,
        0,
        end.x,
        end.y,
      ].join(" ");
    }

    function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
      const angleInRadians = (angleInDegrees * Math.PI) / 180;
      return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians),
      };
    }

    // Draw vector space visualization
    function drawVectorSpace() {
      const centerX = 200;
      const centerY = 200;
      const radius = 150;

      // Draw photo window sectors in vector space
      const morningStartVec = embedTimeAsVector(MORNING_START);
      const morningEndVec = embedTimeAsVector(MORNING_END);
      const morningArc = document.getElementById("morning-arc");

      const morningPath = [
        "M",
        centerX,
        centerY,
        "L",
        centerX + morningStartVec.x * radius,
        centerY + morningStartVec.y * radius,
        "A",
        radius,
        radius,
        0,
        0,
        1, // Changed sweep-flag from 0 to 1 for clockwise
        centerX + morningEndVec.x * radius,
        centerY + morningEndVec.y * radius,
        "Z",
      ].join(" ");
      morningArc.setAttribute("d", morningPath);

      const afternoonStartVec = embedTimeAsVector(AFTERNOON_START);
      const afternoonEndVec = embedTimeAsVector(AFTERNOON_END);
      const afternoonArc = document.getElementById("afternoon-arc");

      const afternoonPath = [
        "M",
        centerX,
        centerY,
        "L",
        centerX + afternoonStartVec.x * radius,
        centerY + afternoonStartVec.y * radius,
        "A",
        radius,
        radius,
        0,
        0,
        1, // Changed sweep-flag from 0 to 1 for clockwise
        centerX + afternoonEndVec.x * radius,
        centerY + afternoonEndVec.y * radius,
        "Z",
      ].join(" ");
      afternoonArc.setAttribute("d", afternoonPath);

      // Position labels at the center of each pie slice
      const morningCenter = (MORNING_START + MORNING_END) / 2;
      const afternoonCenter = (AFTERNOON_START + AFTERNOON_END) / 2;

      const morningCenterVec = embedTimeAsVector(morningCenter);
      const afternoonCenterVec = embedTimeAsVector(afternoonCenter);

      // Position labels at 100px radius from center (closer than the 150px arc)
      const morningLabel = document.getElementById("morning-label");
      const afternoonLabel = document.getElementById("afternoon-label");

      if (morningLabel) {
        morningLabel.setAttribute("x", centerX + morningCenterVec.x * 100);
        morningLabel.setAttribute("y", centerY + morningCenterVec.y * 100 + 4); // +4 for text baseline
      }

      if (afternoonLabel) {
        afternoonLabel.setAttribute("x", centerX + afternoonCenterVec.x * 100);
        afternoonLabel.setAttribute(
          "y",
          centerY + afternoonCenterVec.y * 100 + 4
        ); // +4 for text baseline
      }
    }

    // Update visualization
    function update() {
      const departureHours = parseFloat(departureSlider.value);
      const flightDuration = parseFloat(durationSlider.value);
      const timezoneCrossed = parseFloat(timezonesSlider.value);

      // Calculate arrival time (with timezone change)
      const arrivalHours =
        (departureHours + flightDuration + timezoneCrossed + 24) % 24;

      // Update displays
      const formatTime = (h) => {
        const hours = Math.floor(h);
        const minutes = Math.round((h - hours) * 60);
        return `${hours.toString().padStart(2, "0")}:${minutes
          .toString()
          .padStart(2, "0")}`;
      };

      departureValue.textContent = formatTime(departureHours);
      durationValue.textContent = `${flightDuration.toFixed(1)}h`;
      timezoneValue.textContent =
        timezoneCrossed > 0 ? `+${timezoneCrossed}h` : `${timezoneCrossed}h`;

      // Update clock hands
      const depAngle = (departureHours * 360) / 24 - 90;
      const arrAngle = (arrivalHours * 360) / 24 - 90;

      depHand.setAttribute(
        "x2",
        100 + 70 * Math.cos((depAngle * Math.PI) / 180)
      );
      depHand.setAttribute(
        "y2",
        100 + 70 * Math.sin((depAngle * Math.PI) / 180)
      );

      arrHand.setAttribute(
        "x2",
        100 + 70 * Math.cos((arrAngle * Math.PI) / 180)
      );
      arrHand.setAttribute(
        "y2",
        100 + 70 * Math.sin((arrAngle * Math.PI) / 180)
      );

      // VECTOR EMBEDDING
      const depVec = embedTimeAsVector(departureHours);
      const arrVec = embedTimeAsVector(arrivalHours);

      // Update vector visualization with new dimensions
      const centerX = 200;
      const centerY = 200;
      const radius = 150;

      const depX = centerX + depVec.x * radius;
      const depY = centerY + depVec.y * radius;
      const arrX = centerX + arrVec.x * radius;
      const arrY = centerY + arrVec.y * radius;

      depVector.setAttribute("x2", depX);
      depVector.setAttribute("y2", depY);
      depPoint.setAttribute("cx", depX);
      depPoint.setAttribute("cy", depY);
      depLabel.setAttribute("x", depX);
      depLabel.setAttribute("y", depY - 10);

      arrVector.setAttribute("x2", arrX);
      arrVector.setAttribute("y2", arrY);
      arrPoint.setAttribute("cx", arrX);
      arrPoint.setAttribute("cy", arrY);
      arrLabel.setAttribute("x", arrX);
      arrLabel.setAttribute("y", arrY - 10);

      // Draw arc between vectors
      // Calculate the angular difference to determine the shorter path
      let angularDiff = arrivalHours - departureHours;

      // Normalize to [-12, 12] range to find shorter path
      if (angularDiff > 12) {
        angularDiff -= 24;
      } else if (angularDiff < -12) {
        angularDiff += 24;
      }

      // For the arc to follow the circle:
      // - largeArcFlag: 0 if angular distance < 12 hours (180°), 1 if >= 12 hours
      // - sweepFlag: 1 if going clockwise (positive angular difference), 0 if counter-clockwise
      const largeArcFlag = Math.abs(angularDiff) >= 12 ? 1 : 0;
      const sweepFlag = angularDiff >= 0 ? 1 : 0;

      const arcPath = [
        "M",
        depX,
        depY,
        "A",
        radius,
        radius,
        0,
        largeArcFlag,
        sweepFlag,
        arrX,
        arrY,
      ].join(" ");
      distanceArc.setAttribute("d", arcPath);

      // THIS IS THE KEY COMPARISON!
      const windowAnalysis = findOptimalWindow(arrivalHours);

      // Show pedagogical explanation when methods disagree
      if (
        windowAnalysis.differentChoice ||
        Math.abs(windowAnalysis.naiveWait - windowAnalysis.optimalWait) > 2
      ) {
        // Methods disagree significantly - explain why!
        methodDifference.style.display = "block";

        const formatTime = (h) => {
          const hours = Math.floor(h);
          const minutes = Math.round((h - hours) * 60);
          return `${hours.toString().padStart(2, "0")}:${minutes
            .toString()
            .padStart(2, "0")}`;
        };

        differenceExplanation.innerHTML = `
          <strong>Arrival time: ${formatTime(arrivalHours)}<\/strong><br>
          <strong>Naive method:<\/strong> Looks forward chronologically and says "wait ${windowAnalysis.naiveWait.toFixed(
            1
          )} hours until ${windowAnalysis.naive.name} window"<br>
          <strong>Vector method:<\/strong> Checks ALL directions on the clock and finds "${
            windowAnalysis.optimal.name
          } window is only ${windowAnalysis.optimalWait.toFixed(
          1
        )} hours away"<br>
          <br>
          <strong>Why it breaks:<\/strong> The naive method doesn't understand that time is circular! 
          It treats 23:00 and 01:00 as 22 hours apart instead of just 2 hours. 
          Vector embedding treats time as a circle where midnight connects back to itself.
        `;

        explanationText.textContent =
          "⚠️ The methods disagree! See explanation below.";
      } else {
        methodDifference.style.display = "none";
        explanationText.textContent =
          "Try different settings to see when naive calculation fails.";
      }

      // Show which window each approach recommends
      if (windowAnalysis.differentChoice) {
        naiveDistance.textContent = `${
          windowAnalysis.naive.name
        } (${windowAnalysis.naiveWait.toFixed(1)}h)`;
        vectorDistance.textContent = `${
          windowAnalysis.optimal.name
        } (${windowAnalysis.optimalWait.toFixed(1)}h)`;

        naiveResult.className = "result-card bad";
        vectorResult.className = "result-card good";
      } else {
        naiveDistance.textContent = `${windowAnalysis.naiveWait.toFixed(
          1
        )}h wait`;
        vectorDistance.textContent = `${windowAnalysis.optimalWait.toFixed(
          1
        )}h wait`;

        naiveResult.className =
          Math.abs(windowAnalysis.naiveWait - windowAnalysis.optimalWait) > 1
            ? "result-card bad"
            : "result-card";
        vectorResult.className = "result-card good";
      }

      // Show to nearest window
      morningDistance.textContent = `${windowAnalysis.optimalWait.toFixed(1)}h`;

      // Photo quality assessment
      let quality = "";
      let qualityClass = "";
      const inMorningWindow =
        arrivalHours >= MORNING_START && arrivalHours < MORNING_END;
      const inAfternoonWindow =
        arrivalHours >= AFTERNOON_START && arrivalHours < AFTERNOON_END;

      if (inMorningWindow || inAfternoonWindow) {
        quality = "In window! 🟢";
        qualityClass = "good";
      } else if (windowAnalysis.optimalWait < 1) {
        quality = "< 1h wait 🟡";
        qualityClass = "good";
      } else if (windowAnalysis.optimalWait < 3) {
        quality = `${windowAnalysis.optimalWait.toFixed(1)}h wait 🟠`;
        qualityClass = "";
      } else {
        quality = "Long wait 🔴";
        qualityClass = "bad";
      }

      photoQuality.textContent = quality;
      morningResult.className = `result-card ${
        windowAnalysis.optimalWait < 2 ? "good" : ""
      }`;
      photoReady.className = `result-card ${qualityClass}`;

      // Update distance label (now in HTML outside the SVG)
      const flightTime = circularDistance(departureHours, arrivalHours);
      if (distanceLabel) {
        distanceLabel.textContent = `Flight spans: ${flightTime.toFixed(
          1
        )}h on clock`;
      }
    }

    // Initialize photo windows
    drawPhotoWindows(depClock);
    drawPhotoWindows(arrClock);
    drawVectorSpace();

    // Event listeners
    departureSlider.addEventListener("input", update);
    durationSlider.addEventListener("input", update);
    timezonesSlider.addEventListener("input", update);

    // Toggle button for time display format
    if (timeToggle) {
      timeToggle.addEventListener("click", () => {
        isMilitaryTime = !isMilitaryTime;
        timeToggle.textContent = isMilitaryTime ? "24h" : "12h";

        // Update labels based on the time format
        if (isMilitaryTime) {
          if (labelNorth) labelNorth.textContent = "00:00";
          if (labelEast) labelEast.textContent = "06:00";
          if (labelSouth) labelSouth.textContent = "12:00";
          if (labelWest) labelWest.textContent = "18:00";
        } else {
          if (labelNorth) labelNorth.textContent = "12 AM";
          if (labelEast) labelEast.textContent = "6 AM";
          if (labelSouth) labelSouth.textContent = "12 PM";
          if (labelWest) labelWest.textContent = "6 PM";
        }
      });
    }

    // Hint button toggle
    if (hintButton) {
      hintButton.addEventListener("click", () => {
        const isHidden = hintContent.style.display === "none";
        hintContent.style.display = isHidden ? "block" : "none";
        hintButton.textContent = isHidden
          ? "💡 Hide Hint"
          : "💡 How to Break Naive Calculation";
      });
    }

    // Set initial values that show a subtle difference
    // Start with something that works, let users discover the breaking case
    departureSlider.value = "14"; // 2 PM departure
    durationSlider.value = "3"; // 3 hour flight
    timezonesSlider.value = "-1"; // Cross 1 timezone west

    // Initial update
    update();

    console.log("✅ Flight Photo Window demo initialized");
  } catch (error) {
    console.error("Error initializing Flight Photo Window demo:", error);
  }
}


// GIS longitude wraparound demo for slide 12-gis-demo.html

function initGISDemo() {
  // Check if Leaflet is loaded
  if (typeof L === "undefined") {
    console.log("Leaflet not loaded yet, retrying...");
    setTimeout(initGISDemo, 200);
    return;
  }

  // Check if map container exists
  const mapContainer = document.getElementById("map");
  if (!mapContainer) {
    console.log("Map container not found");
    return;
  }

  // Clear any existing map
  if (window.gisMap) {
    window.gisMap.remove();
    window.gisMap = null;
  }

  try {
    // Add CSS styles for marker labels
    const style = document.createElement('style');
    style.textContent = `
      .wrong-label {
        background-color: #FF1744 !important;
        color: white !important;
        font-weight: bold !important;
        font-size: 12px !important;
        border: none !important;
        border-radius: 4px !important;
        padding: 4px 8px !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3) !important;
      }
      .wrong-label::before {
        border-top-color: #FF1744 !important;
      }
      .right-label {
        background-color: #00C853 !important;
        color: white !important;
        font-weight: bold !important;
        font-size: 12px !important;
        border: none !important;
        border-radius: 4px !important;
        padding: 4px 8px !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3) !important;
      }
      .right-label::before {
        border-top-color: #00C853 !important;
      }
    `;
    document.head.appendChild(style);

    // Center between the Pacific (where pins are) and Atlantic (where wrong answer appears)
    const MAP_CENTER = [10.0, 90.0]; // Centered to show both Pacific pins and Atlantic error

    // Map zoomed out to show both correct answer (Pacific) and wrong answer (Atlantic)
    const map = L.map("map", {
      center: MAP_CENTER,
      zoom: 2, // Zoom out more to show both hemispheres
      worldCopyJump: false,
    });
    window.gisMap = map; // Store reference for cleanup

    // OSM tiles with attribution
    let tiles = L.tileLayer(
      "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      {
        maxZoom: 19,
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap<\/a> contributors',
      }
    ).addTo(map);
    window.gisTiles = tiles;

    // Two draggable points that straddle the International Date Line (the REAL wraparound!)
    const blueIcon = L.divIcon({
      className: "custom-marker",
      html: '<div style="background:var(--bb-info); width:20px; height:20px; border-radius:50%; border:3px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.3);"><\/div>',
      iconSize: [20, 20],
      iconAnchor: [10, 10],
    });
    const orangeIcon = L.divIcon({
      className: "custom-marker",
      html: '<div style="background:var(--bb-gold); width:20px; height:20px; border-radius:50%; border:3px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.3);"><\/div>',
      iconSize: [20, 20],
      iconAnchor: [10, 10],
    });

    const marker1 = L.marker([5.0, 170.0], { draggable: true, icon: blueIcon })
      .addTo(map)
      .bindTooltip("170°E", { permanent: true, direction: "right" });
    // Use +190° instead of -170° to ensure it appears on the same map copy as 170°
    const marker2 = L.marker([15.0, 190.0], {
      draggable: true,
      icon: orangeIcon,
    })
      .addTo(map)
      .bindTooltip("190°E (-170°)", { permanent: true, direction: "left" });
    const pts = [marker1, marker2];
    window.gisMarkers = pts;

    console.log(
      "Created GIS markers:",
      pts.length,
      "markers at positions:",
      pts.map((m) => `${m.getLatLng().lat},${m.getLatLng().lng}`)
    );

    // Circular mean helper function
    function meanLonDeg(ds) {
      let x = 0,
        y = 0;
      for (const d of ds) {
        const r = (d * Math.PI) / 180;
        x += Math.cos(r);
        y += Math.sin(r);
      }
      let m = (Math.atan2(y, x) * 180) / Math.PI;
      // For this demo, keep result in range [-180, 180] but prefer positive values near dateline
      if (m < -180) m += 360;
      if (m > 180) m -= 360;
      return m;
    }

    // Result markers - RED for wrong, GREEN for correct with permanent labels
    const wrongMarker = L.circleMarker(MAP_CENTER, {
      radius: 12,
      color: "#FF1744",
      fillColor: "#FF5252",
      fillOpacity: 0.9,
      weight: 3,
    })
      .addTo(map)
      .bindTooltip("WRONG", {
        permanent: true,
        direction: "top",
        className: "wrong-label",
        offset: [0, -15]
      });

    const correctMarker = L.circleMarker(MAP_CENTER, {
      radius: 15,
      color: "#00C853",
      fillColor: "#4CAF50",
      fillOpacity: 0.9,
      weight: 3,
    })
      .addTo(map)
      .bindTooltip("RIGHT", {
        permanent: true,
        direction: "top",
        className: "right-label",
        offset: [0, -15]
      });
    const readout = document.getElementById("readout");

    window.gisResultMarkers = [wrongMarker, correctMarker];

    function update() {
      const lats = pts.map((m) => m.getLatLng().lat);
      const lons = pts.map((m) => m.getLatLng().lng);
      const latAvg = lats.reduce((a, b) => a + b, 0) / lats.length;

      // Update marker tooltips with current positions
      // Normalize longitude for display (keep in -180 to 180 range)
      let displayLon1 = lons[0];
      let displayLon2 = lons[1];
      if (displayLon2 > 180) displayLon2 -= 360; // Convert 190° back to -170° for display

      marker1.setTooltipContent(`${displayLon1.toFixed(1)}°`);
      marker2.setTooltipContent(`${displayLon2.toFixed(1)}°`);

      // Naive linear mean - just averages the longitude values directly
      // When points are on opposite sides of date line (e.g. 170° and -170°),
      // this gives 180° which is wrong (should be 180°)
      const naiveLinMean = (displayLon1 + displayLon2) / 2;

      // Correct circular mean - use the normalized display values
      const circMean = meanLonDeg([displayLon1, displayLon2]);

      // Debug logging
      console.log(`Blue: ${displayLon1.toFixed(1)}°, Orange: ${displayLon2.toFixed(1)}°`);
      console.log(`Naive linear: ${naiveLinMean.toFixed(1)}°, Circular: ${circMean.toFixed(1)}°`);

      // Ensure markers appear on the main visible map copy
      let correctLon = circMean;
      let wrongLon = naiveLinMean;

      // Fix the green pin positioning - if it's in the western hemisphere near dateline, convert to positive equivalent
      if (correctLon < -90) {
        correctLon += 360; // Convert negative western longitudes to positive equivalent
      }

      // For the red pin, if it's in the eastern hemisphere when pins are western,
      // it should stay where it is (the naive wrong answer)

      wrongMarker.setLatLng([latAvg, wrongLon]);
      correctMarker.setLatLng([latAvg, correctLon]);

      // Show a reference line at the Prime Meridian (0°) when naive mean is wrong
      if (window.crossLine) map.removeLayer(window.crossLine);
      if (Math.abs(naiveLinMean - circMean) > 90) {
        // Large difference means we're crossing the date line
        window.crossLine = L.polyline(
          [
            [latAvg - 5, 0],
            [latAvg + 5, 0],
          ],
          { color: "#FFC107", weight: 2, dashArray: "5,5" }
        ).addTo(map);
      }

      if (readout) {
        // For display, show the mathematical result but indicate position
        let displayCorrectLon = circMean;
        if (correctLon > 180) {
          displayCorrectLon = circMean; // Show original calculation (-176°)
        }
        readout.textContent = `✅ Circular mean: ${displayCorrectLon.toFixed(
          1
        )}° | ❌ Naive linear mean: ${wrongLon.toFixed(1)}°`;
      }
    }

    pts.forEach((m) => m.on("drag dragend", update));
    update();

    // UI toggles
    const worldCopyCheckbox = document.getElementById("worldCopy");
    const noWrapTilesCheckbox = document.getElementById("noWrapTiles");

    if (worldCopyCheckbox) {
      worldCopyCheckbox.addEventListener("change", (e) => {
        map.options.worldCopyJump = !!e.target.checked;
        map.panBy([1, 0]); // nudge to apply visually
      });
    }

    if (noWrapTilesCheckbox) {
      noWrapTilesCheckbox.addEventListener("change", (e) => {
        const noWrap = !!e.target.checked;
        map.removeLayer(tiles);
        tiles = L.tileLayer(
          "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          {
            maxZoom: 19,
            attribution:
              '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap<\/a> contributors',
            noWrap,
          }
        ).addTo(map);
        window.gisTiles = tiles;
      });
    }

    console.log("GIS demo initialized");
  } catch (error) {
    console.error("Error initializing GIS demo:", error);
  }
}


function initHueDragWheel() {
  // Get reference to the SVG element
  const svg = document.getElementById("dwSVG");
  if (!svg) {
    console.error("Could not find hue drag wheel SVG element");
    return;
  }

  // Define constants for the hue wheel
  const R = 179;  // Radius corrected to visual center of the ring
  const S = 100;  // Saturation percentage for HSL colors
  const L = 50;   // Lightness percentage for HSL colors

  const lineA = svg.querySelector("#lineA");
  const lineB = svg.querySelector("#lineB");
  const lineMid = svg.querySelector("#lineMid");
  const lineNaive = svg.querySelector("#lineNaive");
  const hA = svg.querySelector("#handleA");
  const hB = svg.querySelector("#handleB");
  const hMid = svg.querySelector("#handleMid");
  const hNaive = svg.querySelector("#handleNaive");
  const labA = svg.querySelector("#labelA");
  const labB = svg.querySelector("#labelB");
  const labMid = svg.querySelector("#labelMid");
  const labNaive = svg.querySelector("#labelNaive");
  const arc = svg.querySelector("#dwArc");

  const degA = document.getElementById("degA");
  const degB = document.getElementById("degB");
  const degMid = document.getElementById("degMid");
  const degNaive = document.getElementById("degNaive");
  const dotA = document.getElementById("dotA");
  const dotB = document.getElementById("dotB");
  const dotMid = document.getElementById("dotMid");
  const dotNaive = document.getElementById("dotNaive");
  const barCircular = document.getElementById("barCircular");
  const barNaive = document.getElementById("barNaive");

  // Helpers
  const clamp360 = (h) => ((h % 360) + 360) % 360;
  const deg2rad = (d) => (d * Math.PI) / 180;
  const rad2deg = (r) => (r * 180) / Math.PI;

  // Rotated hue wheel: red at North (0°), hue increases clockwise
  function posOnRing(h) {
    const a = deg2rad(h - 90); // Apply -90deg rotation
    return [200 + R * Math.cos(a), 200 + R * Math.sin(a)];
  }
  function hueFromPoint(x, y) {
    const a = Math.atan2(y - 200, x - 200);
    return clamp360(rad2deg(a) + 90); // Apply +90deg rotation
  }
  function shortestDelta(a, b) {
    return ((b - a + 540) % 360) - 180;
  } // [-180,180)
  function circularMid(h1, h2) {
    return clamp360(h1 + 0.5 * shortestDelta(h1, h2));
  }
  function naiveMid(h1, h2) {
    return clamp360((h1 + h2) / 2);
  }

  function setVector(elLine, elHandle, elLabel, hue, width = 7, dash = null) {
    const [x, y] = posOnRing(hue);
    elLine.setAttribute("x2", x);
    elLine.setAttribute("y2", y);
    // Color the line according to its hue
    elLine.setAttribute("stroke", `hsl(${hue}, ${S}%, ${L}%)`);
    elLine.setAttribute("stroke-width", width);
    if (dash) {
      elLine.setAttribute("stroke-dasharray", dash);
    } else {
      elLine.removeAttribute("stroke-dasharray");
    }
    elHandle.setAttribute("cx", x);
    elHandle.setAttribute("cy", y);
    // Color the handle with the same hue, slightly lighter
    elHandle.setAttribute(
      "fill",
      `hsl(${hue}, ${S}%, ${Math.min(70, L + 20)}%)`
    );
    // Position label slightly outside the handle
    const labelOffset = 18;
    const angle = deg2rad(hue - 90); // Apply rotation for label positioning
    elLabel.setAttribute("x", x + labelOffset * Math.cos(angle));
    elLabel.setAttribute("y", y + labelOffset * Math.sin(angle));
  }
  function setChip(dot, degree, hue) {
    dot.style.background = `hsl(${hue}, ${S}%, ${L}%)`;
    degree.textContent = `${Math.round(hue)}°`;
  }
  function setArc(h1, h2) {
    const dShort = shortestDelta(h1, h2);
    // Always draw the shortest arc
    const large = Math.abs(dShort) > 180 ? 1 : 0;
    const sweepFlag = dShort > 0 ? 1 : 0; // Positive delta = clockwise sweep
    const [ax, ay] = posOnRing(h1);
    const [bx, by] = posOnRing(h2);
    arc.setAttribute(
      "d",
      `M ${ax} ${ay} A ${R} ${R} 0 ${large} ${sweepFlag} ${bx} ${by}`
    );
  }
  function setBars(h1, h2) {
    const steps = 30;
    const colsCirc = [],
      colsNaive = [];
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const hm = clamp360(h1 + shortestDelta(h1, h2) * t);
      const hn = clamp360(h1 + (h2 - h1) * t);
      colsCirc.push(`hsl(${hm}, ${S}%, ${L}%)`);
      colsNaive.push(`hsl(${hn}, ${S}%, ${L}%)`);
    }
    barCircular.style.background = `linear-gradient(90deg, ${colsCirc.join(
      ","
    )})`;
    barNaive.style.background = `linear-gradient(90deg, ${colsNaive.join(
      ","
    )})`;
  }

  // State
  let H1 = 340, // Start with red-magenta
    H2 = 40;  // Start with orange
  function render() {
    const Hmid = circularMid(H1, H2);
    const Hnaive = naiveMid(H1, H2);
    setVector(lineA, hA, labA, H1, 7, null);
    setVector(lineB, hB, labB, H2, 7, null);
    setVector(lineMid, hMid, labMid, Hmid, 7, null);
    setVector(lineNaive, hNaive, labNaive, Hnaive, 5, "4,6");
    setChip(dotA, degA, H1);
    setChip(dotB, degB, H2);
    setChip(dotMid, degMid, Hmid);
    setChip(dotNaive, degNaive, Hnaive);
    setArc(H1, H2);
    setBars(H1, H2);
  }

  // Dragging
  function makeDraggable(handle, which) {
    let dragging = false;
    function onDown(e) {
      dragging = true;
      e.preventDefault();
      handle.setPointerCapture?.(e.pointerId);
    }
    function onMove(e) {
      if (!dragging) return;
      const r = svg.getBoundingClientRect();
      const x = e.clientX - r.left,
        y = e.clientY - r.top;
      const hue = hueFromPoint(x, y);
      if (which === "A") H1 = hue;
      else H2 = hue;
      render();
    }
    function onUp(e) {
      dragging = false;
      handle.releasePointerCapture?.(e.pointerId);
    }
    handle.addEventListener("pointerdown", onDown);
    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp);
  }
  makeDraggable(hA, "A");
  makeDraggable(hB, "B");

  // Click on ring to set nearest handle
  svg.addEventListener("pointerdown", (e) => {
    const r = svg.getBoundingClientRect();
    const x = e.clientX - r.left,
      y = e.clientY - r.top;
    const hue = hueFromPoint(x, y);
    const dA = Math.abs(shortestDelta(hue, H1)),
      dB = Math.abs(shortestDelta(hue, H2));
    if (dA <= dB) H1 = hue;
    else H2 = hue;
    render();
  });

  render();
}


// Interactive angle averaging demo for slide 11-interactive-demo.html

function initInteractiveDemo() {
  const angle1Input = document.getElementById("angle1");
  const angle2Input = document.getElementById("angle2");
  const angle1Display = document.getElementById("angle1-display");
  const angle2Display = document.getElementById("angle2-display");
  const wrongResult = document.getElementById("wrong-result");
  const correctResult = document.getElementById("correct-result");

  // Check if elements exist (safety check)
  if (!angle1Input || !angle2Input) {
    console.log("Interactive demo elements not found");
    return;
  }

  function updateDemo() {
    const a1 = parseInt(angle1Input.value);
    const a2 = parseInt(angle2Input.value);

    // Update displays
    angle1Display.textContent = a1 + "°";
    angle2Display.textContent = a2 + "°";

    // Calculate wrong (linear) average
    const wrongAvg = (a1 + a2) / 2;
    wrongResult.textContent = Math.round(wrongAvg) + "°";

    // Calculate correct (circular) average
    const theta1 = (a1 * Math.PI) / 180;
    const theta2 = (a2 * Math.PI) / 180;
    const v1 = [Math.cos(theta1), Math.sin(theta1)];
    const v2 = [Math.cos(theta2), Math.sin(theta2)];
    const avgVec = [(v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2];
    const norm = Math.sqrt(avgVec[0] ** 2 + avgVec[1] ** 2);
    avgVec[0] /= norm;
    avgVec[1] /= norm;
    const correctAvg = (Math.atan2(avgVec[1], avgVec[0]) * 180) / Math.PI;
    const correctAvgNormalized = (correctAvg + 360) % 360;
    correctResult.textContent = Math.round(correctAvgNormalized) + "°";

    // Update visual
    updateVisual(a1, a2, wrongAvg, correctAvgNormalized);

    // Show/hide wrong result based on how wrong it is
    const wrongness = Math.abs(wrongAvg - correctAvgNormalized);
    const adjustedWrongness = Math.min(wrongness, 360 - wrongness);
    const opacity = adjustedWrongness > 30 ? 1 : 0;

    const wrongLine = document.getElementById("avg-wrong-line");
    const wrongPoint = document.getElementById("avg-wrong-point");
    if (wrongLine) wrongLine.style.opacity = opacity;
    if (wrongPoint) wrongPoint.style.opacity = opacity;
  }

  function updateVisual(a1, a2, wrongAvg, correctAvg) {
    const cx = 200,
      cy = 200,
      r = 150;

    // Convert angles to positions
    function angleToPos(angle) {
      const rad = ((angle - 90) * Math.PI) / 180; // -90 to start from top
      return {
        x: cx + r * Math.cos(rad),
        y: cy + r * Math.sin(rad),
      };
    }

    const pos1 = angleToPos(a1);
    const pos2 = angleToPos(a2);
    const wrongPos = angleToPos(wrongAvg);
    const correctPos = angleToPos(correctAvg);

    // Update lines and points safely
    const elements = [
      { id: "angle1-line", x2: pos1.x, y2: pos1.y },
      { id: "angle1-point", cx: pos1.x, cy: pos1.y },
      { id: "angle2-line", x2: pos2.x, y2: pos2.y },
      { id: "angle2-point", cx: pos2.x, cy: pos2.y },
      { id: "avg-wrong-line", x2: wrongPos.x, y2: wrongPos.y },
      { id: "avg-wrong-point", cx: wrongPos.x, cy: wrongPos.y },
      { id: "avg-correct-line", x2: correctPos.x, y2: correctPos.y },
      { id: "avg-correct-point", cx: correctPos.x, cy: correctPos.y },
    ];

    elements.forEach((elem) => {
      const element = document.getElementById(elem.id);
      if (element) {
        if (elem.x2 !== undefined) element.setAttribute("x2", elem.x2);
        if (elem.y2 !== undefined) element.setAttribute("y2", elem.y2);
        if (elem.cx !== undefined) element.setAttribute("cx", elem.cx);
        if (elem.cy !== undefined) element.setAttribute("cy", elem.cy);
      }
    });
  }

  // Set up event listeners
  angle1Input.addEventListener("input", updateDemo);
  angle2Input.addEventListener("input", updateDemo);

  // Initial update
  updateDemo();

  console.log("Interactive demo initialized");
}


const slides = Array.from(document.querySelectorAll('.slide'));
    const progressBar = document.getElementById('progress');
    const counter = document.getElementById('counter');
    const controls = document.querySelector('.controls');
    let currentIndex = 0;
    let fadeTimer = null;

    // Auto-fade controls
    function startFadeTimer() {
      // Clear any existing timer
      if (fadeTimer) {
        clearTimeout(fadeTimer);
      }
      
      // Show controls immediately
      controls.classList.remove('fade-out');
      controls.classList.add('fade-in');
      
      // Start fade out after 2 seconds (1 second stable + 1 second fade)
      fadeTimer = setTimeout(() => {
        controls.classList.remove('fade-in');
        controls.classList.add('fade-out');
      }, 2000);
    }

    // Show controls when user interacts
    function showControls() {
      controls.classList.remove('fade-out');
      controls.classList.add('fade-in');
      startFadeTimer();
    }

    function showSlide(index) {
      // Remove all classes
      slides.forEach(s => {
        s.classList.remove('active', 'prev');
      });
      
      // Wrap around
      currentIndex = (index + slides.length) % slides.length;
      
      // Set classes
      slides[currentIndex].classList.add('active');
      if (currentIndex > 0) {
        slides[currentIndex - 1].classList.add('prev');
      } else {
        slides[slides.length - 1].classList.add('prev');
      }
      
      // Reset scroll position for new slide
      slides[currentIndex].scrollTop = 0;
      
      // Update UI
      counter.textContent = `${currentIndex + 1} / ${slides.length}`;
      progressBar.style.width = `${((currentIndex + 1) / slides.length) * 100}%`;
      
      // Show controls and start fade timer
      showControls();
    }

    // Navigation with control show
    document.getElementById('prev').onclick = () => {
      showControls();
      showSlide(currentIndex - 1);
    };
    
    document.getElementById('next').onclick = () => {
      showControls();
      showSlide(currentIndex + 1);
    };

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      switch(e.key) {
        case 'ArrowRight':
        case ' ':
          e.preventDefault();
          showSlide(currentIndex + 1);
          break;
        case 'ArrowLeft':
          e.preventDefault();
          showSlide(currentIndex - 1);
          break;
        case 'f':
        case 'F':
          e.preventDefault();
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
          } else {
            document.exitFullscreen();
          }
          break;
        case 'p':
        case 'P':
          e.preventDefault();
          window.print();
          break;
        case 'Home':
          e.preventDefault();
          showSlide(0);
          break;
        case 'End':
          e.preventDefault();
          showSlide(slides.length - 1);
          break;
      }
    });

    // Touch/swipe support
    let touchStartX = 0;
    let touchEndX = 0;
    let touchStartY = 0;
    let touchEndY = 0;

    document.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
      // Show controls when touching
      showControls();
    });

    document.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;
      handleSwipe();
    });

    function handleSwipe() {
      const horizontalDiff = Math.abs(touchEndX - touchStartX);
      const verticalDiff = Math.abs(touchEndY - touchStartY);
      
      // Only trigger if horizontal swipe is stronger than vertical
      if (horizontalDiff > verticalDiff && horizontalDiff > 50) {
        if (touchEndX < touchStartX) {
          showSlide(currentIndex + 1); // Swipe left = next
        } else {
          showSlide(currentIndex - 1); // Swipe right = previous
        }
      }
    }

    // Initialize
    showSlide(0);

    // Hide mobile hint after first interaction
    let hasInteracted = false;
    function hideHint() {
      if (!hasInteracted) {
        hasInteracted = true;
        const hint = document.querySelector('.mobile-swipe-hint');
        if (hint) {
          hint.style.opacity = '0';
          setTimeout(() => hint.style.display = 'none', 500);
        }
      }
    }

    document.addEventListener('touchstart', hideHint);
    document.addEventListener('click', hideHint);

    // Show controls if user taps anywhere on screen
    document.addEventListener('click', (e) => {
      // Don't trigger if clicking on controls themselves
      if (!e.target.closest('.controls')) {
        showControls();
      }
    });


    </script>
</body>
</html>
