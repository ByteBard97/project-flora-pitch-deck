<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stop Fighting Wraparound: Embed Your Rings!</title>
    <style>
:root {
  /* Updated with Ceres logo color palette */
  --bg: #0a1a1f;
  --card: #10161d;
  --ink: #dbe2eb;
  --muted: #9fb0c6;
  --accent: #22d3ee; /* Cyan from logo */
  --accent2: #4ade80; /* Green from logo */
  --accent3: #ff7b7b;
  --warning: #ffb86c;
  --ceres-dark: #0a1a1f;
  --ceres-green: #4ade80;
  --ceres-cyan: #22d3ee;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  height: 100%;
  margin: 0;
  background: radial-gradient(
    1000px 800px at 70% 10%,
    #0e1420 0%,
    var(--bg) 60%
  );
  color: var(--ink);
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto,
    Inter, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.35;
}

.slideshow-container {
  position: relative;
  width: 100%;
  height: 100vh;
  display: grid;
  grid-template-rows: 1fr auto;
}

#slide-content {
  padding: 56px 64px;
  background: radial-gradient(
      600px 400px at 10% 5%,
      rgba(112, 181, 255, 0.06),
      transparent 50%
    ),
    radial-gradient(
      700px 500px at 90% 0%,
      rgba(155, 255, 176, 0.05),
      transparent 60%
    );
  border-radius: 12px;
  margin: 20px;
  height: calc(100vh - 80px);
  overflow-y: auto;
  animation: fadeIn 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

h1 {
  font-size: 54px;
  font-weight: 750;
  letter-spacing: -0.02em;
  line-height: 1.1;
  color: var(--ink);
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 36px;
  font-weight: 700;
  letter-spacing: -0.01em;
  line-height: 1.1;
  color: var(--ink);
  margin: 30px 0 20px 0;
  border-left: 4px solid var(--accent);
  padding-left: 20px;
}

h3 {
  font-size: 22px;
  font-weight: 650;
  color: var(--muted);
  margin: 20px 0 15px 0;
}

h4 {
  font-size: 18px;
  font-weight: 600;
  color: var(--ink);
  margin: 15px 0 10px 0;
}

p,
li {
  font-size: 20px;
  color: #c9d6e5;
  line-height: 1.5;
}

.subtitle {
  text-align: center;
  color: var(--muted);
  font-size: 22px;
  margin-bottom: 40px;
}

.two-column {
  display: grid;
  grid-template-columns: 1.1fr 1fr;
  gap: 26px;
  align-items: start;
  margin: 30px 0;
}

.two-column-equal {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 26px;
  align-items: start;
  margin: 30px 0;
}

.two-column-equal img {
  width: 100%;
  height: auto;
  object-fit: contain;
}

.three-column {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 26px;
  margin: 30px 0;
}

.card,
.highlight-box,
.success-box,
.warning-box,
.info-box {
  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.04),
    rgba(255, 255, 255, 0.02)
  );
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 18px 20px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
  margin: 20px 0;
}

.highlight-box {
  border-left: 4px solid var(--accent3);
  background: linear-gradient(
    180deg,
    rgba(255, 123, 123, 0.08),
    rgba(255, 123, 123, 0.04)
  );
}

.success-box {
  border-left: 4px solid var(--accent2);
  background: linear-gradient(
    180deg,
    rgba(155, 255, 176, 0.08),
    rgba(155, 255, 176, 0.04)
  );
}

.warning-box {
  border-left: 4px solid var(--warning);
  background: linear-gradient(
    180deg,
    rgba(255, 184, 108, 0.08),
    rgba(255, 184, 108, 0.04)
  );
}

.info-box {
  border-left: 4px solid var(--accent);
  background: linear-gradient(
    180deg,
    rgba(112, 181, 255, 0.08),
    rgba(112, 181, 255, 0.04)
  );
}

ul,
ol {
  margin: 15px 0;
  padding-left: 30px;
}

ul.compact li {
  margin-bottom: 8px;
}

li {
  margin: 8px 0;
}

.metric {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.07);
  padding: 16px;
  border-radius: 14px;
  margin: 10px 0;
  text-align: center;
}

.metric-value {
  font-size: 36px;
  font-weight: 800;
  color: var(--accent);
}

.metric-label {
  color: var(--muted);
  font-size: 14px;
  margin-top: 4px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

.code-block {
  background: rgba(0, 0, 0, 0.4);
  color: var(--ink);
  padding: 20px;
  border-radius: 12px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
  font-size: 16px;
  margin: 15px 0;
  overflow-x: auto;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.navigation {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  display: flex;
  gap: 8px;
}

.nav-button {
  background: rgba(255, 255, 255, 0.06);
  color: var(--ink);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 10px;
  padding: 8px 12px;
  cursor: pointer;
  font-weight: 600;
  font-size: 1em;
  transition: all 0.3s;
}

.nav-button:hover {
  background: rgba(255, 255, 255, 0.12);
  transform: translateY(-2px);
}

.nav-button:disabled {
  background: rgba(255, 255, 255, 0.03);
  color: var(--muted);
  cursor: not-allowed;
  transform: none;
}

.nav-button:focus {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

.slide-counter {
  position: fixed;
  bottom: 30px;
  right: 30px;
  background: rgba(0, 0, 0, 0.5);
  color: var(--ink);
  padding: 10px 15px;
  border-radius: 20px;
  font-size: 14px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.status-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin: 20px 0;
}

.status-item {
  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.04),
    rgba(255, 255, 255, 0.02)
  );
  border: 2px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 20px;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}

.status-item.completed {
  border-color: var(--accent2);
  background: linear-gradient(
    180deg,
    rgba(155, 255, 176, 0.08),
    rgba(155, 255, 176, 0.04)
  );
}

.status-item.in-progress {
  border-color: var(--warning);
  background: linear-gradient(
    180deg,
    rgba(255, 184, 108, 0.08),
    rgba(255, 184, 108, 0.04)
  );
}

.status-item.critical {
  border-color: var(--accent3);
  background: linear-gradient(
    180deg,
    rgba(255, 123, 123, 0.08),
    rgba(255, 123, 123, 0.04)
  );
}

.timeline {
  position: relative;
  margin: 30px 0;
}

.timeline-item {
  margin: 20px 0;
  padding-left: 40px;
  position: relative;
}

.timeline-item::before {
  content: "";
  position: absolute;
  left: 15px;
  top: 8px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--accent);
}

.timeline-item::after {
  content: "";
  position: absolute;
  left: 20px;
  top: 20px;
  width: 2px;
  height: calc(100% + 10px);
  background: rgba(255, 255, 255, 0.1);
}

.timeline-item:last-child::after {
  display: none;
}

.process-flow {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin: 30px 0;
  flex-wrap: wrap;
}

.process-step {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 20px;
  margin: 10px;
  text-align: center;
  flex: 1;
  min-width: 200px;
  position: relative;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.process-step::after {
  content: "‚Üí";
  position: absolute;
  right: -25px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 2em;
  color: var(--accent);
}

.process-step:last-child::after {
  display: none;
}

.mask-example {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 20px;
  margin: 20px 0;
  align-items: center;
}

.mask-box {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.08);
  padding: 20px;
  border-radius: 12px;
  text-align: center;
}

.operation {
  font-size: 2em;
  color: var(--accent);
  font-weight: bold;
}

.badge {
  padding: 3px 8px;
  border-radius: 999px;
  font-size: 12px;
  color: #0a1422;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  font-weight: 700;
  display: inline-block;
}

.mono {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
  font-size: 16px;
}

.kpi {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 16px;
}

.kpi .stat {
  text-align: center;
  padding: 16px;
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.07);
}

.kpi .num {
  font-size: 36px;
  font-weight: 800;
  color: var(--accent);
}

.kpi .label {
  font-size: 14px;
  color: var(--muted);
  margin-top: 4px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

/* Operation list styles for slide 4 */
.operation-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin: 15px 0;
}

.op-item {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 8px;
  padding: 12px 16px;
  transition: all 0.2s ease;
}

.op-item:hover {
  background: rgba(255, 255, 255, 0.04);
  border-color: rgba(255, 255, 255, 0.12);
}

.op-item strong {
  color: var(--accent);
  font-weight: 650;
}

.op-item small {
  color: var(--muted);
  font-size: 14px;
  margin-top: 4px;
  display: block;
}

.code-example {
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 20px;
  margin: 15px 0;
}

.formula-showcase {
  text-align: center;
  background: rgba(255, 255, 255, 0.02);
  padding: 16px;
  border-radius: 10px;
  margin: 15px 0;
  border: 1px solid rgba(255, 255, 255, 0.06);
}

.formula-showcase code {
  font-size: 18px;
  font-weight: 600;
  color: var(--accent);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
}

/* Scrollbar styling for dark theme */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Title slide specific styles */
.title-slide {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background: linear-gradient(135deg, var(--ceres-dark) 0%, #1a2f33 100%);
  color: white;
  padding: 2em;
  position: relative;
}

.logo-container {
  margin-bottom: 2em;
  animation: fadeInScale 0.8s ease-out;
}

.title-logo {
  width: 200px;
  height: auto;
  filter: drop-shadow(0 10px 30px rgba(34, 211, 238, 0.3));
}

@keyframes fadeInScale {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.main-title {
  font-size: 3.5em;
  margin-bottom: 0.2em;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
  background: linear-gradient(90deg, var(--ceres-green), var(--ceres-cyan));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.visual-element {
  margin: 2em 0;
}

.presenter-info {
  margin-top: 2em;
  text-align: center;
}

.presenter-info p {
  margin: 0.5em 0;
  font-size: 1.2em;
}

.company-branding {
  margin: 1em 0;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.1em;
}

.Ceres-logo {
  font-size: 2.2em;
  font-weight: 700;
  color: #4caf50;
  letter-spacing: 0.05em;
  text-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
}

.Ceres-ai {
  font-size: 2.2em;
  font-weight: 300;
  color: #70b5ff;
  letter-spacing: 0.05em;
  text-shadow: 0 2px 4px rgba(112, 181, 255, 0.3);
}

.presenter-info .date {
  font-size: 2em;
  font-weight: 300;
  margin-bottom: 1em;
}

/* Common visual demo styles */
.visual-demo {
  display: flex;
  justify-content: center;
  margin: 2em 0;
}

.code-comparison {
  display: flex;
  gap: 1em;
  margin: 1em 0;
}

.clock-visual {
  margin: 2em 0;
  display: flex;
  justify-content: center;
}

/* Interactive demo styles */
.demo-container {
  display: flex;
  gap: 2em;
  align-items: flex-start;
  margin: 2em 0;
}

.demo-section {
  flex: 2;
}

.code-section {
  flex: 1;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 20px;
}

.angle-inputs {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin: 20px 0;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 12px;
  padding: 20px;
}

.angle-inputs label {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 16px;
  color: var(--ink);
}

.angle-inputs input[type="range"] {
  flex: 1;
  margin: 0 15px;
  appearance: none;
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.1);
  outline: none;
}

.angle-inputs input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
}

.angle-inputs input[type="range"]::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: none;
}

.angle-inputs span {
  min-width: 50px;
  font-weight: 600;
  color: var(--accent);
}

.demo-visual {
  display: flex;
  justify-content: center;
  margin: 20px 0;
  background: rgba(255, 255, 255, 0.01);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 12px;
  padding: 20px;
}

.demo-results {
  display: flex;
  gap: 20px;
  justify-content: center;
  margin: 20px 0;
}

.result {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 15px 20px;
  text-align: center;
  min-width: 140px;
}

.wrong-result {
  border-left: 4px solid var(--accent3);
}

.correct-result {
  border-left: 4px solid var(--accent2);
}

.result h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
}

.result p {
  margin: 0;
  font-size: 24px;
  font-weight: 700;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
}

.wrong-result p {
  color: var(--accent3);
}

.correct-result p {
  color: var(--accent2);
}

/* Print styles */
@media print {
  body {
    background: white;
    color: #111;
  }

  #slide-content {
    background: white;
    color: #111;
    border: none;
    box-shadow: none;
    page-break-after: always;
  }

  .navigation,
  .slide-counter {
    display: none !important;
  }

  h1,
  h2,
  h3,
  p,
  li {
    color: #111;
  }

  .card,
  .highlight-box,
  .success-box,
  .warning-box,
  .info-box,
  .status-item {
    background: #fff;
    border: 1px solid #e5e7eb;
    box-shadow: none;
    color: #111;
  }
}

/* Visual comparison layout for robot heading diagrams */
.visual-comparison {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: 2em;
  margin: 2em 0;
  flex-wrap: wrap;
}

.visual-comparison .approach {
  flex: 1;
  max-width: 500px;
  text-align: center;
}

.visual-comparison svg {
  margin: 0 auto;
  display: block;
}

.text-center {
  text-align: center;
}

    </style>
    
    <!-- Code syntax highlighting with Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    
    <!-- Leaflet CSS for GIS demo -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">

    <!-- D3 UMD (exposes window.d3) -->
    <script src="https://d3js.org/d3.v7.min.js" defer></script>

    <!-- D3FC UMD bundle (exposes window.fc, includes label-layout) -->
    <script src="https://unpkg.com/d3fc@15" defer></script>
    
    <!-- Code block styling -->
    <style>
        /* Style code blocks */
        pre code {
            border: 1px solid rgba(255,255,255,0.1) !important;
            border-radius: 12px !important;
            padding: 20px !important;
            display: block;
        }
        
        /* Maintain our colored container backgrounds */
        .bad-code, .code-example {
            background: linear-gradient(180deg, rgba(255,123,123,0.08), rgba(255,123,123,0.04)) !important;
            border-left: 4px solid var(--accent3) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }
        
        .good-code, .code-solution {
            background: linear-gradient(180deg, rgba(155,255,176,0.08), rgba(155,255,176,0.04)) !important;
            border-left: 4px solid var(--accent2) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }
        
        .implementation-example {
            background: linear-gradient(180deg, rgba(156,39,176,0.08), rgba(156,39,176,0.04)) !important;
            border-left: 4px solid #9C27B0 !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }
        
        .universal-class {
            background: linear-gradient(180deg, rgba(33,150,243,0.08), rgba(33,150,243,0.04)) !important;
            border-left: 4px solid #2196F3 !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }
        
        .approach-bad, .approach-good {
            background: rgba(255,255,255,0.04) !important;
            border: 1px solid rgba(255,255,255,0.08) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        /* Crisp "halo" under label text to keep it readable */
        svg text {
            paint-order: stroke;
            stroke: rgba(8,12,16,.75);
            stroke-width: 3;
        }
        /* Optional: keep strokes consistent when scaling */
        svg *[stroke] {
            vector-effect: non-scaling-stroke;
        }
    </style>

    <!-- Math rendering with MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            options: {
                renderActions: {
                    addMenu: []  // Disable context menu for cleaner presentation
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="slideshow-container">
        <div id="slide-content"></div>
    </div>

    <!-- Navigation -->
    <div class="navigation">
        <button class="nav-button" onclick="previousSlide()">‚óÄ Previous</button>
        <button class="nav-button" onclick="nextSlide()">Next ‚ñ∂</button>
    </div>

    <!-- Slide Counter -->
    <div class="slide-counter">
        <span id="current-slide">1</span> / <span id="total-slides">0</span>
    </div>

    <!-- Code highlighting JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    
    <!-- Leaflet JavaScript for GIS demo -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- PixiJS for interactive math demos -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            hljs.highlightAll();

            // Sanity check for D3 and fc libraries
            console.log("‚úÖ D3 loaded?", typeof d3);
            console.log("‚úÖ fc loaded?", typeof fc);

            if (typeof d3 !== 'undefined' && typeof fc !== 'undefined') {
                console.log("‚úÖ D3 version:", d3.version);
                console.log("‚úÖ fc.layoutLabel exists?", typeof fc.layoutLabel);
            } else {
                console.error("‚ùå D3 or fc libraries failed to load!");
            }
        });

        // Helper function to expand SVG viewBox to prevent text cutoff
        function expandViewBox(svg, pad = 20) {
            console.log("üìê expandViewBox called with padding:", pad);
            const node = svg.node ? svg.node() : svg;
            const box = node.getBBox();
            const oldViewBox = node.getAttribute("viewBox");
            const newViewBox = [
                box.x - pad,
                box.y - pad,
                box.width + 2 * pad,
                box.height + 2 * pad
            ].join(" ");

            console.log("   Old viewBox:", oldViewBox);
            console.log("   New viewBox:", newViewBox);

            if (svg.attr) {
                svg.attr("viewBox", newViewBox);
            } else {
                node.setAttribute("viewBox", newViewBox);
            }
        }

        // Helper function to wait for libraries to load
        function waitForLibraries(callback, maxRetries = 20) {
            let retries = 0;
            const checkInterval = setInterval(() => {
                retries++;
                if (window.d3 && window.fc) {
                    console.log("‚úÖ D3 and fc libraries loaded");
                    clearInterval(checkInterval);
                    callback();
                } else if (retries >= maxRetries) {
                    console.warn("‚ö†Ô∏è Timeout waiting for D3/fc libraries after", retries, "attempts");
                    clearInterval(checkInterval);
                } else {
                    console.log("‚è≥ Waiting for D3/fc libraries... attempt", retries);
                }
            }, 100);
        }

        // Helper function to fix SVG text layout and prevent overlap
        function fixSVGLayout(svgElement) {
            console.log("üîß fixSVGLayout called for SVG element");

            if (!window.d3 || !window.fc) {
                console.warn("‚ö†Ô∏è D3 or fc libraries not loaded yet, will retry...");
                waitForLibraries(() => {
                    console.log("üîÑ Retrying fixSVGLayout after libraries loaded");
                    fixSVGLayout(svgElement);
                });
                return;
            }

            const svg = d3.select(svgElement);
            console.log("   SVG selected with D3");

            // Expand viewBox to prevent edge clipping
            expandViewBox(svg, 25);

            // Optional: Apply label layout if there are many text elements
            const textElements = svg.selectAll("text");
            console.log('   Found ' + textElements.size() + ' text elements');

            if (textElements.size() > 4) {
                console.log("   Applying d3fc label layout for", textElements.size(), "text elements");
                // For complex layouts with many labels, use d3fc-label-layout
                try {
                    const labels = textElements.nodes();
                    const layout = fc.layoutLabel()
                        .size(d => {
                            const box = d.getBBox();
                            return [box.width, box.height];
                        })
                        .position(d => {
                            const x = parseFloat(d.getAttribute("x") || 0);
                            const y = parseFloat(d.getAttribute("y") || 0);
                            return [x, y];
                        });

                    svg.datum(labels).call(layout);
                    console.log("   ‚úÖ Label layout applied successfully");
                } catch (e) {
                    console.warn("   ‚ùå Label layout failed:", e);
                }
            } else {
                console.log("   Skipping label layout (not enough text elements)");
            }
        }

        // Helper function to compute safe SVG bounds
        function computeSvgBounds(svgNode) {
            const svg = d3.select(svgNode);
            const vbAttr = svg.attr("viewBox");
            if (vbAttr) {
                const nums = vbAttr.trim().split(/\s+/).map(Number);
                if (nums.length === 4 && nums.every(Number.isFinite)) {
                    const [vx, vy, vw, vh] = nums;
                    if (vw > 0 && vh > 0) return { x: vx, y: vy, width: vw, height: vh };
                }
            }
            // fallback: bbox + padding, and set a sane viewBox
            const b = svgNode.getBBox();
            const bounds = { x: b.x - 16, y: b.y - 16, width: b.width + 32, height: b.height + 32 };
            svg.attr("viewBox", bounds.x + " " + bounds.y + " " + bounds.width + " " + bounds.height);
            return bounds;
        }

        // Move existing <text> elements with d3fc (no new labels are created)
        window.applyLabelLayout = function applyLabelLayout(svgNode, { anneal = false } = {}) {
            if (!window.d3 || !window.fc) {
                console.warn("applyLabelLayout: d3/fc not present");
                return;
            }

            console.log('üè∑Ô∏è Applying label layout (reuse existing labels)');
            const svg = d3.select(svgNode);
            const textsSel = svg.selectAll("text");
            const textNodes = textsSel.nodes();

            if (textNodes.length < 2) {
                console.log('   Skipping layout (less than 2 text elements)');
                return; // nothing to resolve
            }

            // normalize anchors to reduce surprises
            textsSel
                .attr("dominant-baseline", function () { return this.getAttribute("dominant-baseline") || "middle"; })
                .attr("text-anchor", function () { return this.getAttribute("text-anchor") || "middle"; });

            const bounds = computeSvgBounds(svgNode);
            console.log('   Using bounds:', bounds);

            // pick strategy
            const base = anneal ? fc.layoutAnnealing() : fc.layoutGreedy();
            const strategy = fc.layoutRemoveOverlaps(base.bounds(bounds));

            // NO component: we don't want new nodes rendered
            const noop = () => {};

            // layout that measures & reads current positions off each datum (the SVGTextElement)
            const layout = fc.layoutLabel(strategy)
                .size(function (d) {
                    const bb = d.getBBox();
                    return [bb.width + 8, bb.height + 6];  // padding around label boxes
                })
                .position(function (d) {
                    return [ +d.getAttribute("x") || 0, +d.getAttribute("y") || 0 ];
                })
                .component(noop);

            // bind nodes as data and run layout
            svg.datum(textNodes).call(layout);

            // now bind those datums to the text selection
            textsSel.data(textNodes);

            // write solved positions back; keep old value as fallback
            textsSel
                .attr("x", function (d) { return (d && Number.isFinite(d.x)) ? d.x : +this.getAttribute("x"); })
                .attr("y", function (d) { return (d && Number.isFinite(d.y)) ? d.y : +this.getAttribute("y"); });
            console.log('   ‚úÖ Label layout applied to', textNodes.length, 'existing text elements (no new nodes created)');
        };

        // Move every <text> to the end of its parent so it paints on top
        function bringTextToFront(svgEl) {
            console.log('üì§ Bringing text elements to front');
            const texts = svgEl.querySelectorAll('text');
            texts.forEach(t => t.parentNode.appendChild(t)); // append = top of paint order
            console.log('   ‚úÖ Moved', texts.length, 'text elements to front');
        }

        // Ensure SVG has the filter definitions for labels
        function ensureLabelFilters(svgEl) {
            const NS = "http://www.w3.org/2000/svg";
            let defs = svgEl.querySelector("defs");
            if (!defs) {
                defs = document.createElementNS(NS, "defs");
                svgEl.insertBefore(defs, svgEl.firstChild);
            }

            if (!svgEl.querySelector("#label-shadow")) {
                const f = document.createElementNS(NS, "filter");
                f.setAttribute("id", "label-shadow");
                f.innerHTML = '<feDropShadow dx="0" dy=".7" stdDeviation="1.2" flood-color="#000" flood-opacity=".55"/>';
                defs.appendChild(f);
            }
            if (!svgEl.querySelector("#label-glow")) {
                const f = document.createElementNS(NS, "filter");
                f.setAttribute("id", "label-glow");
                f.setAttribute("x", "-20%");
                f.setAttribute("y", "-20%");
                f.setAttribute("width", "140%");
                f.setAttribute("height", "140%");
                f.innerHTML = '<feGaussianBlur in="SourceAlpha" stdDeviation="1.4" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>';
                defs.appendChild(f);
            }
        }

        // Apply styling filters to labels
        function styleLabels(svgEl, { use = "shadow" } = {}) {
            console.log('üé® Applying', use, 'filter to text labels');
            ensureLabelFilters(svgEl);
            const texts = svgEl.querySelectorAll("text");
            texts.forEach(t => {
                t.setAttribute("filter", 'url(#label-' + use + ')');
            });
            console.log('   ‚úÖ Applied', use, 'filter to', texts.length, 'text elements');
        }

        // Reduce the size of filled endpoint circles; leave stroked rings alone
        function shrinkEndpoints(svgEl, targetR = 5) {
            console.log('üî¥ Shrinking endpoint bulbs to radius', targetR);
            let shrunkCount = 0;
            svgEl.querySelectorAll('circle').forEach(c => {
                const r0 = +c.getAttribute('r') || 0;
                const fill = (c.getAttribute('fill') || '').trim().toLowerCase();
                const hasFill = fill && fill !== 'none';
                // Heuristic: rings in your slides have fill="none", endpoints are filled
                if (hasFill && r0 > targetR) {
                    c.setAttribute('r', targetR);
                    shrunkCount++;
                }
            });
            console.log('   ‚úÖ Shrunk', shrunkCount, 'filled circles from larger sizes to', targetR);
        }

        // Called after each slide's SVG is inserted (comprehensive enhancement pipeline)
        window.fixSVGLayoutAndLabels = function fixSVGLayoutAndLabels(svgEl) {
            console.log('üîß fixSVGLayoutAndLabels called - running full enhancement pipeline');

            if (window.fixSVGLayout) {
                window.fixSVGLayout(svgEl);         // your viewBox pad step
            }
            if (window.applyLabelLayout) {
                window.applyLabelLayout(svgEl);     // space labels (greedy)
            }
            bringTextToFront(svgEl);                // labels above graphics
            styleLabels(svgEl, { use: "shadow" });  // halo + subtle shadow
            shrinkEndpoints(svgEl, 5);              // smaller bulbs globally

            console.log('   ‚úÖ Enhancement pipeline completed');
        };

        // Auto-fix all SVGs when a slide is loaded
        window.addEventListener("slideLoaded", () => {
            console.log("üìÑ slideLoaded event received");
            const svgs = document.querySelectorAll("#slide-content svg");
            console.log('   Found ' + svgs.length + ' SVG(s) in slide content');

            if (svgs.length > 0) {
                // Wait for libraries to be ready before processing SVGs
                if (!window.d3 || !window.fc) {
                    console.log("‚è≥ Libraries not ready, waiting...");
                    waitForLibraries(() => {
                        svgs.forEach((svg, index) => {
                            console.log('   Processing SVG ' + (index + 1) + '/' + svgs.length);
                            fixSVGLayoutAndLabels(svg);
                        });
                    });
                } else {
                    svgs.forEach((svg, index) => {
                        console.log('   Processing SVG ' + (index + 1) + '/' + svgs.length);
                        fixSVGLayoutAndLabels(svg);
                    });
                }
            }
        });
    </script>
    

    
    
    
    <script>
// Embedded slide data for bundled version
window.slideData = {
  "0": "<div class='slide title-slide'> <div class='logo-container'> <img src='../ceres-tech-logo.png' alt='Ceres AI Logo' class='title-logo'> </div> <h1 class='main-title'>Stop Fighting Wraparound</h1> <h2 class='subtitle'>Embed Your Rings!</h2> <div class='visual-element'> <svg width='400' height='200' viewBox='0 0 400 200'> <!-- Circle representing wraparound --> <circle cx='100' cy='100' r='80' fill='none' stroke='#4CAF50' stroke-width='3' /> <!-- Points near wraparound --> <circle cx='170' cy='100' r='8' fill='#FF5722' /> <circle cx='30' cy='100' r='8' fill='#2196F3' /> <!-- Arrow showing 'wrong' linear distance --> <path d='M 170 100 L 30 100' stroke='#FF5722' stroke-width='2' stroke-dasharray='5,5' opacity='0.5' /> <text x='100' y='90' text-anchor='middle' fill='#FF5722' font-size='14'> 140¬∞ apart? </text> <!-- Arrow showing correct arc distance --> <path d='M 170 100 A 80 80 0 0 0 30 100' fill='none' stroke='#4CAF50' stroke-width='3' /> <text x='100' y='130' text-anchor='middle' fill='#4CAF50' font-size='14' fill='#FFC107' > 20¬∞ apart! </text> <!-- Embedding arrow --> <path d='M 220 100 L 280 100' stroke='#666' stroke-width='2' marker-end='url(#arrowhead)' /> <text x='250' y='90' text-anchor='middle' fill='#666' font-size='12' fill='#FFC107' > embed </text> <!-- 2D representation --> <g transform='translate(320, 100)'> <line x1='-50' y1='0' x2='50' y2='0' stroke='#999' stroke-width='1' /> <line x1='0' y1='-50' x2='0' y2='50' stroke='#999' stroke-width='1' /> <circle cx='40' cy='0' r='8' fill='#FF5722' /> <circle cx='-40' cy='0' r='8' fill='#2196F3' /> <text x='0' y='-60' text-anchor='middle' fill='#666' font-size='12' fill='#FFC107' > ‚Ñù¬≤ </text> </g> <!-- Arrow marker --> <defs> <marker id='arrowhead' markerWidth='10' markerHeight='7' refX='10' refY='3.5' orient='auto' > <polygon points='0 0, 10 3.5, 0 7' fill='#666' /> </marker> </defs> </svg> </div> <div class='presenter-info'> <p>A practical guide to handling circular quantities in code</p> <p class='author'>Ceres</p> <p class='date'>Tech Talk</p> </div> </div>",

  "1": "<div class='slide'> <h1>The Bug We've All Written</h1> <div class='highlight-box'> <h3>‚ùå The Naive Approach</h3> <pre><code class='language-python'>def average_angle(angle1, angle2):\n    return (angle1 + angle2) / 2  # Seems reasonable...\n# Example: Average heading between two compass readings\nheading1 = 350  # degrees\nheading2 = 10   # degrees\naverage = average_angle(heading1, heading2)\nprint(f'Average: {average}¬∞')  # 180¬∞ - COMPLETELY WRONG!</code></pre> </div> <div class='visual-demo'> <svg width='600' height='600' viewBox='0 0 300 300'> <!-- Compass circle --> <circle cx='150' cy='150' r='120' fill='none' stroke='#333' stroke-width='2'/> <!-- Compass labels with stroke for better readability --> <text x='150' y='20' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>N (0¬∞)</text> <text x='280' y='155' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>E (90¬∞)</text> <text x='150' y='290' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>S (180¬∞)</text> <text x='20' y='155' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>W (270¬∞)</text> <!-- Heading 1: 350¬∞ --> <line x1='150' y1='150' x2='140' y2='30' stroke='#2196F3' stroke-width='4'/> <circle cx='140' cy='30' r='8' fill='#2196F3'/> <text x='110' y='20' font-size='14' fill='#FFC107'>350¬∞</text> <!-- Heading 2: 10¬∞ --> <line x1='150' y1='150' x2='160' y2='30' stroke='#4CAF50' stroke-width='4'/> <circle cx='160' cy='30' r='8' fill='#4CAF50'/> <text x='190' y='20' font-size='14' fill='#FFC107'>10¬∞</text> <!-- Wrong average: 180¬∞ --> <line x1='150' y1='150' x2='150' y2='270' stroke='#FF5722' stroke-width='4' stroke-dasharray='5,5'/> <circle cx='150' cy='270' r='8' fill='#FF5722'/> <text x='150' y='260' text-anchor='middle' font-size='16' fill='#FF5722' font-weight='bold'> Wrong: 180¬∞ </text> <!-- Correct average indicator --> <line x1='150' y1='150' x2='150' y2='30' stroke='#FFC107' stroke-width='3' opacity='0.7'/> <text x='220' y='60' font-size='14' fill='#ffffff' font-weight='bold'>Should be ~0¬∞!</text> </svg> </div> <div class='warning-box'> <h3>What Went Wrong?</h3> <ul> <li>350¬∞ and 10¬∞ are <strong>20¬∞ apart</strong> on the circle</li> <li>But linear math sees them as <strong>340¬∞ apart</strong></li> <li>The average points in the <strong>opposite direction</strong>!</li> </ul> </div> </div> <script> // Fix SVG layout and labels when this slide is displayed console.log('üéØ Slide 02-the-bug script executing'); setTimeout(() => {     console.log('üéØ Slide 02-the-bug timeout triggered');     const svg = document.querySelector('.visual-demo svg');     if (svg) {         console.log('   Found SVG in .visual-demo');         if (window.fixSVGLayoutAndLabels) {             console.log('   Calling fixSVGLayoutAndLabels from slide script');             window.fixSVGLayoutAndLabels(svg);         } else {             console.warn('   fixSVGLayoutAndLabels function not found on window');         }     } else {         console.warn('   No SVG found in .visual-demo');     } }, 100); <\/script>",

  "2": "<div class='slide'> <h1>The Midnight Bug</h1> <div class='info-box'> <h3>üìÖ Real Scenario: Event Duration Tracking</h3> <p>Meeting started at <strong>23:45</strong> (11:45 PM)</p> <p>Meeting ended at <strong>00:15</strong> (12:15 AM)</p> </div> <div class='code-comparison'> <div class='highlight-box'> <h4>‚ùå What Everyone Tries First</h4> <pre><code>start_time = 23.75  # 23:45 in decimal hours\nend_time = 0.25     # 00:15 in decimal hours\nduration = end_time - start_time\nprint(f'Duration: {duration} hours')\n# Output: -23.5 hours ü§¶</code></pre> </div> <div class='warning-box'> <h4>ü§î The Hacky 'Fix'</h4> <pre><code>if end_time < start_time:\n    # Must have crossed midnight\n    duration = (24 - start_time) + end_time\nelse:\n    duration = end_time - start_time\n    \n# More special cases...\nif crossed_dst:  # Daylight savings\n    duration += 1  # or -1? üò≠</code></pre> </div> </div> <div class='clock-visual'> <svg width='1200' height='500' viewBox='0 0 800 300'> <!-- Linear representation --> <g transform='translate(30, 80)'> <text x='150' y='-20' text-anchor='middle' font-size='14' font-weight='bold' fill='#FFC107'>Linear View:</text> <line x1='0' y1='20' x2='300' y2='20' stroke='#333' stroke-width='2'/> <!-- Time markers --> <line x1='0' y1='15' x2='0' y2='25' stroke='#333' stroke-width='2'/> <text x='0' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>0:00</text> <line x1='150' y1='15' x2='150' y2='25' stroke='#333' stroke-width='2'/> <text x='150' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>12:00</text> <line x1='300' y1='15' x2='300' y2='25' stroke='#333' stroke-width='2'/> <text x='300' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>24:00</text> <!-- Start time: 23:45 (23.75/24 * 300 = 296.25) --> <circle cx='296' cy='20' r='8' fill='#2196F3'/> <text x='296' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>23:45</text> <!-- End time: 00:15 (0.25/24 * 300 = 3.125) --> <circle cx='3' cy='20' r='8' fill='#4CAF50'/> <text x='3' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>00:15</text> <!-- Wrong distance --> <path d='M 296 20 L 3 20' stroke='#FF5722' stroke-width='2' stroke-dasharray='5,5' opacity='0.5'/> <text x='150' y='80' text-anchor='middle' fill='#FF5722' font-size='14'>Linear: -23.5 hours!</text> </g> <!-- Circular representation --> <g transform='translate(550, 150)'> <text x='0' y='-90' text-anchor='middle' font-size='14' font-weight='bold' fill='#FFC107'>Circular View:</text> <circle cx='0' cy='0' r='70' fill='none' stroke='#333' stroke-width='2'/> <!-- Clock numbers --> <text x='0' y='-55' text-anchor='middle' font-size='12' fill='#FFC107'>12</text> <text x='55' y='5' text-anchor='middle' font-size='12' fill='#FFC107'>3</text> <text x='0' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>6</text> <text x='-55' y='5' text-anchor='middle' font-size='12' fill='#FFC107'>9</text> <!-- Start: 23:45 --> <line x1='0' y1='0' x2='-10' y2='-68' stroke='#2196F3' stroke-width='3'/> <circle cx='-10' cy='-68' r='8' fill='#2196F3'/> <!-- End: 00:15 --> <line x1='0' y1='0' x2='10' y2='-68' stroke='#4CAF50' stroke-width='3'/> <circle cx='10' cy='-68' r='8' fill='#4CAF50'/> <!-- Correct arc --> <path d='M -10 -68 A 70 70 0 0 1 10 -68' fill='none' stroke='#4CAF50' stroke-width='3'/> <text x='0' y='90' text-anchor='middle' fill='#4CAF50' font-size='14' font-weight='bold'> Correct: 30 minutes! </text> </g> </svg> </div> <div class='success-box'> <h3>üí° The Key Insight</h3> <p>Time-of-day is a <strong>24-hour ring</strong>, not a line!</p> <p>Linear arithmetic breaks at the wraparound point.</p> </div> </div>",

  "3": "<div class='slide'> <h1>The Missing Math Class: Circular Operations</h1> <div class='warning-box'> <h3>ü§Ø What They Never Taught You</h3> <p>Circular quantities are everywhere, but traditional math classes skip the operations entirely! Here's what you can actually <strong>do</strong> once you embed them as vectors:</p> </div> <div class='two-column-equal'> <div class='card'> <h3>üìä Basic Operations</h3> <div class='operation-list'> <div class='op-item'> <strong>Addition:</strong> <code>v‚ÇÅ + v‚ÇÇ</code><br> <small>Compose two rotations</small> </div> <div class='op-item'> <strong>Subtraction:</strong> <code>v‚ÇÅ - v‚ÇÇ</code><br> <small>Find angular difference</small> </div> <div class='op-item'> <strong>Average:</strong> <code>mean(vectors)</code><br> <small>Circular mean (always works!)</small> </div> <div class='op-item'> <strong>Interpolation:</strong> <code>slerp(v‚ÇÅ, v‚ÇÇ, t)</code><br> <small>Smooth rotation between angles</small> </div> </div> </div> <div class='card'> <h3>üßÆ Advanced Operations</h3> <div class='operation-list'> <div class='op-item'> <strong>Distance:</strong> <code>shortest_path(Œ∏‚ÇÅ, Œ∏‚ÇÇ)</code><br> <small>Minimal angular separation</small> </div> <div class='op-item'> <strong>Scaling:</strong> <code>scalar √ó vector</code><br> <small>Scale magnitude, preserve direction</small> </div> <div class='op-item'> <strong>Derivatives:</strong> <code>d/dt [cos(œât), sin(œât)]</code><br> <small>Angular velocity vectors</small> </div> <div class='op-item'> <strong>Integration:</strong> <code>‚à´ œâ(t) dt</code><br> <small>Accumulate rotations over time</small> </div> </div> </div> </div> <div class='success-box'> <h3>üìà Circular Statistics (The Really Cool Stuff)</h3> <div class='code-example'> <pre><code class='language-python'># Operations that actually work on circular data!\nangles = [350¬∞, 10¬∞, 5¬∞, 355¬∞]  # Wind directions\nvectors = [to_vector(Œ∏) for Œ∏ in angles]\n# Circular mean (not 180¬∞!)\nmean_vector = np.mean(vectors, axis=0) \nmean_angle = from_vector(mean_vector)  # ‚âà 0¬∞\n# Circular standard deviation  \ndispersion = 1 - |mean_vector|  # How 'spread out' are they?\n# Circular correlation\ncorrelation = correlate_circular(wind_dir, wave_dir)\n# Circular regression (yes, this exists!)\nslope, intercept = circular_regression(time, wave_directions)</code></pre> </div> </div> <div class='info-box'> <h3>üéØ Why This Matters</h3> <div class='three-column'> <div> <h4>üåä Oceanography</h4> <p>Wave directions, current flows</p> </div> <div> <h4>üß≠ Navigation</h4> <p>GPS, compass bearings, flight paths</p> </div> <div> <h4>üß¨ Biology</h4> <p>Circadian rhythms, animal migration</p> </div> <div> <h4>üéµ Signal Processing</h4> <p>Phase analysis, Fourier transforms</p> </div> <div> <h4>ü§ñ Robotics</h4> <p>Joint angles, orientation control</p> </div> <div> <h4>üìä Data Science</h4> <p>Seasonal trends, cyclic patterns</p> </div> </div> </div> <div class='highlight-box'> <h3>üí° The Big Insight</h3> <p><strong>Every operation you know from linear algebra works on circular quantities‚Äîyou just need to embed them first!</strong> This is why embedding is such a powerful mathematical technique.</p> <div class='formula-showcase'> <code>Circular Quantity ‚Üí Vector ‚Üí Linear Operation ‚Üí Vector ‚Üí Circular Result</code> </div> </div> </div>",

  "4": "<div class='slide'> <h1>Circular Statistics: The Hidden Superpower</h1> <div class='warning-box'> <h3>ü§Ø What Statistics Class Never Taught You</h3> <p>Standard statistics breaks horribly on circular data. But vector embedding makes circular statistics <strong>trivially easy</strong>‚Äîand incredibly powerful!</p> </div> <div class='two-column-equal'> <div class='card'> <h3>üìä The Problem with Regular Stats</h3> <div class='code-example'> <pre><code class='language-python'># Wind directions (degrees)\nangles = [350, 10, 5, 355]\n# Regular mean = DISASTER\nmean = sum(angles) / len(angles)  # = 180¬∞\n# 180¬∞ is the OPPOSITE direction! ü§¶‚Äç‚ôÇÔ∏è\n# Regular standard deviation = MEANINGLESS\nstd = numpy.std(angles)  # = 187¬∞\n# Standard deviation larger than the range!</code></pre> </div> </div> <div class='card'> <h3>‚ú® Vector Statistics = Magic</h3> <div class='code-example'> <pre><code class='language-python'># Convert to vectors\nvectors = [angle_to_vector(Œ∏) for Œ∏ in angles]\n# Circular mean = WORKS!\nmean_vector = np.mean(vectors, axis=0)\nmean_angle = vector_to_angle(mean_vector)  # ‚âà 0¬∞\n# Correct direction! üéØ\n# Circular standard deviation\nR = |mean_vector|  # Mean vector length\ncircular_std = sqrt(-2 * log(R))  # ‚âà 22¬∞\n# Sensible measure of spread!</code></pre> </div> </div> </div> <div class='info-box'> <h3>üß† The Key Insight: Mean Vector Length</h3> <div class='two-column'> <div class='visual-element'> <svg width='300' height='200' viewBox='0 0 300 200'> <!-- Tight cluster --> <g transform='translate(75, 100)'> <circle r='50' fill='none' stroke='#666' stroke-width='1' opacity='0.3'/> <!-- Data points clustered tightly --> <circle cx='45' cy='5' r='4' fill='#4CAF50'/> <circle cx='47' cy='-3' r='4' fill='#4CAF50'/> <circle cx='43' cy='3' r='4' fill='#4CAF50'/> <circle cx='46' cy='0' r='4' fill='#4CAF50'/> <!-- Strong mean vector --> <path d='M 0 0 L 40 0' stroke='#FF5722' stroke-width='4' marker-end='url(#arrow)'/> <text x='0' y='-65' text-anchor='middle' fill='#4CAF50' font-size='12'>Tight Cluster</text> <text x='0' y='75' text-anchor='middle' fill='#FF5722' font-size='11'>|R| ‚âà 0.95</text> <text x='0' y='87' text-anchor='middle' fill='#666' font-size='10'>Low variance</text> </g> <!-- Spread out data --> <g transform='translate(225, 100)'> <circle r='50' fill='none' stroke='#666' stroke-width='1' opacity='0.3'/> <!-- Data points spread out --> <circle cx='45' cy='5' r='4' fill='#2196F3'/> <circle cx='-30' cy='35' r='4' fill='#2196F3'/> <circle cx='-15' cy='-45' r='4' fill='#2196F3'/> <circle cx='20' cy='-40' r='4' fill='#2196F3'/> <!-- Weak mean vector --> <path d='M 0 0 L 8 -5' stroke='#FF5722' stroke-width='4' marker-end='url(#arrow)'/> <text x='0' y='-65' text-anchor='middle' fill='#2196F3' font-size='12'>Spread Out</text> <text x='0' y='75' text-anchor='middle' fill='#FF5722' font-size='11'>|R| ‚âà 0.1</text> <text x='0' y='87' text-anchor='middle' fill='#666' font-size='10'>High variance</text> </g> <defs> <marker id='arrow' markerWidth='10' markerHeight='7' refX='10' refY='3.5' orient='auto'> <polygon points='0 0, 10 3.5, 0 7' fill='#FF5722'/> </marker> </defs> </svg> </div> <div> <h4>üí° The Beautiful Truth</h4> <div class='formula-showcase'> <p><strong>Tight cluster:</strong> Mean vector is long (|R| ‚Üí 1)</p> <p><strong>Spread out:</strong> Mean vector is short (|R| ‚Üí 0)</p> <p><strong>Uniform circle:</strong> Mean vector ‚âà 0</p> </div> <p>The length of the mean vector automatically captures how 'concentrated' your circular data is!</p> </div> </div> </div> <div class='success-box'> <h3>üî¨ Advanced Circular Stats That Actually Work</h3> <div class='code-example'> <pre><code class='language-python'># Circular correlation between two angular variables\ndef circular_correlation(angles1, angles2):\n    v1 = [angle_to_vector(Œ∏) for Œ∏ in angles1]\n    v2 = [angle_to_vector(Œ∏) for Œ∏ in angles2]\n    # Standard correlation on the vector components\n    return pearsonr(v1, v2)\n# Circular regression (yes, this exists!)\ndef circular_regression(x, circular_y):\n    vectors_y = [angle_to_vector(Œ∏) for Œ∏ in circular_y]\n    # Regress each component separately\n    cos_model = LinearRegression().fit(x, [v[0] for v in vectors_y])\n    sin_model = LinearRegression().fit(x, [v[1] for v in vectors_y])\n    return cos_model, sin_model\n# Watson-Williams test (circular ANOVA)\n# Test if multiple groups have the same mean direction\ndef watson_williams_test(group1_angles, group2_angles):\n    # Convert to vectors, compute mean directions, test significance\n    # (This is the circular equivalent of a t-test!)</code></pre> </div> </div> <div class='highlight-box'> <h3>üåü Real-World Applications</h3> <div class='three-column'> <div> <h4>üß¨ Biology</h4> <p><strong>Animal migration:</strong> Test if birds change direction by season</p> <p><strong>Circadian rhythms:</strong> Correlate activity with time of day</p> </div> <div> <h4>üåä Earth Sciences</h4> <p><strong>Wind patterns:</strong> Seasonal wind direction changes</p> <p><strong>Ocean currents:</strong> Correlation with tidal cycles</p> </div> <div> <h4>üéµ Signal Processing</h4> <p><strong>Phase analysis:</strong> Correlation between signal phases</p> <p><strong>Circular convolution:</strong> Periodic signal filtering</p> </div> </div> </div> </div>",

  "5": "<div class='slide'> <h1>Discrete Calculus on Circles: Data-Driven Operations</h1> <div class='info-box'> <h3>üìä Real-World Data = Discrete Samples</h3> <p>In practice, we don't have continuous functions‚Äîwe have <strong>time series data</strong> of circular quantities. How do we compute derivatives and integrals when our data wraps around?</p> </div> <div class='two-column-equal'> <div class='card'> <h3>üìà Discrete Derivatives (Angular Velocity)</h3> <div class='code-example'> <pre><code class='language-python'># WRONG: Naive difference breaks at wraparound\nangles = [358¬∞, 359¬∞, 1¬∞, 2¬∞]  # Smooth rotation\nnaive_diff = [1¬∞, 2¬∞, -357¬∞]  # HUGE SPIKE! üí•\n# RIGHT: Vector space derivative\nvectors = [(cos(Œ∏), sin(Œ∏)) for Œ∏ in angles]\ndvdt = [(v[i+1] - v[i])/dt for i in range(len(v)-1)]\n# Angular velocity from vector derivative\nœâ = cross_product(v[i], dvdt[i]) / |v[i]|¬≤\n# Result: [1¬∞/s, 1¬∞/s, 1¬∞/s] ‚úÖ</code></pre> </div> </div> <div class='card'> <h3>üìâ Discrete Integrals (Accumulated Rotation)</h3> <div class='code-example'> <pre><code class='language-python'># WRONG: Sum angles directly\nangular_velocities = [90¬∞/s, 90¬∞/s, 90¬∞/s, 90¬∞/s]\nnaive_sum = sum(angular_velocities) * dt  # 360¬∞???\n# RIGHT: Accumulate in vector space\nv_accumulated = [1, 0]  # Start at 0¬∞\nfor œâ in angular_velocities:\n    # Rotate vector by angular increment\n    dŒ∏ = œâ * dt\n    rotation = [[cos(dŒ∏), -sin(dŒ∏)],\n                [sin(dŒ∏), cos(dŒ∏)]]\n    v_accumulated = rotation @ v_accumulated\nfinal_angle = atan2(v_accumulated)  # Correct!</code></pre> </div> </div> </div> <div class='success-box'> <h3>üîß Practical Applications in Data Science</h3> <div class='two-column'> <div> <h4>üåä Wind Speed Analysis</h4> <div class='code-example'> <pre><code class='language-python'># Wind direction time series (sampled every hour)\nwind_dirs = [350¬∞, 355¬∞, 0¬∞, 5¬∞, 10¬∞]  # North-ish\nwind_speeds = [10, 12, 15, 14, 11]  # mph\n# Compute wind vector components\nu = [-speed * sin(dir) for speed, dir in zip(wind_speeds, wind_dirs)]\nv = [-speed * cos(dir) for speed, dir in zip(wind_speeds, wind_dirs)]\n# Now can compute proper derivatives!\ndu_dt = np.gradient(u)  # Wind acceleration (east)\ndv_dt = np.gradient(v)  # Wind acceleration (north)</code></pre> </div> </div> <div> <h4>ü§ñ Robot Heading Tracking</h4> <div class='code-example'> <pre><code class='language-python'># IMU gives heading samples at 100Hz\nheadings = sensor.get_heading_buffer()  # [Œ∏‚ÇÅ, Œ∏‚ÇÇ, ..., Œ∏‚Çô]\ndt = 0.01  # 10ms between samples\n# Convert to unit vectors\nvectors = [(cos(h), sin(h)) for h in headings]\n# Compute angular velocity using discrete derivative\nangular_vel = []\nfor i in range(len(vectors)-1):\n    # Cross product gives rotation rate\n    œâ = (vectors[i][0]*vectors[i+1][1] - \n         vectors[i][1]*vectors[i+1][0]) / dt\n    angular_vel.append(œâ)\n# Smooth using windowed average (no wraparound issues!)\nsmoothed_œâ = moving_average(angular_vel, window=10)</code></pre> </div> </div> </div> </div> <div class='warning-box'> <h3>‚ö†Ô∏è Common Pitfalls with Discrete Circular Data</h3> <div class='three-column'> <div> <h4>‚ùå Phase Unwrapping</h4> <p><code>unwrap([350¬∞, 10¬∞])</code> ‚Üí <code>[350¬∞, 370¬∞]</code></p> <p>Creates artificial trends! Use vectors instead.</p> </div> <div> <h4>‚ùå Modulo Arithmetic</h4> <p><code>(Œ∏‚ÇÇ - Œ∏‚ÇÅ) % 360</code></p> <p>Loses direction info. Vector difference preserves it.</p> </div> <div> <h4>‚ùå Averaging Raw Angles</h4> <p><code>mean([0¬∞, 90¬∞, 180¬∞, 270¬∞])</code> ‚Üí <code>135¬∞</code></p> <p>Should be undefined! Vector mean ‚Üí 0.</p> </div> </div> </div> <div class='highlight-box'> <h3>üéØ The Key Pattern for Discrete Operations</h3> <div class='formula-showcase'> <div style='text-align: center; padding: 20px;'> <p style='font-size: 18px; margin: 10px 0;'> <strong>Discrete Samples</strong> ‚Üí <strong>Vector Time Series</strong> ‚Üí <strong>Standard Numpy Operations</strong> ‚Üí <strong>Interpret Results</strong> </p> <p style='margin-top: 20px;'> <code>Œ∏[t]</code> ‚Üí <code>[cos(Œ∏[t]), sin(Œ∏[t])]</code> ‚Üí <code>np.gradient(), np.cumsum()</code> ‚Üí <code>atan2() if needed</code> </p> </div> </div> <p><strong>Bottom Line:</strong> NumPy/Pandas operations 'just work' on vector representations‚Äîno special circular functions needed!</p> </div> </div>",

  "6": "<div class='slide'> <h1>Hidden Rings Everywhere: Beyond Angles & Time</h1> <div class='warning-box'> <h3>üîç Circular Quantities Hide in Plain Sight</h3> <p>It's not just angles, time, and colors that wrap around. Here are the sneaky cyclic variables that cause bugs when you least expect them:</p> </div> <div class='pattern-table'> <table style='width: 100%; border-collapse: collapse;'> <thead> <tr style='background: rgba(33, 150, 243, 0.1); border-bottom: 2px solid #2196F3;'> <th style='padding: 12px; text-align: left; width: 30%;'>Domain</th> <th style='padding: 12px; text-align: left; width: 35%;'>‚ùå Where Naive Math Fails</th> <th style='padding: 12px; text-align: left; width: 35%;'>‚úÖ Correct Embedding</th> </tr> </thead> <tbody> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>üìÖ Weekdays</strong><br><code>d ‚àà {0..6}</code></td> <td style='padding: 10px;'>Mean of Sat(6) and Mon(1) = 3.5 (Wed)?<br><span style='color: #FF5722;'>Wrong! Should be Sunday</span></td> <td style='padding: 10px;'><code>(cos(2œÄd/7), sin(2œÄd/7))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>üîß Rotary Encoders</strong><br><code>n ‚àà [0, 4096)</code></td> <td style='padding: 10px;'>4095 ‚Üí 1 looks like ‚àí4094 ticks<br><span style='color: #FF5722;'>Actually just 2 ticks forward!</span></td> <td style='padding: 10px;'><code>(cos(2œÄn/N), sin(2œÄn/N))</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>üåç Longitude</strong><br><code>Œª ‚àà [‚àí180¬∞, 180¬∞)</code></td> <td style='padding: 10px;'>Mean of 179¬∞E and 179¬∞W = 0¬∞?<br><span style='color: #FF5722;'>Points are 2¬∞ apart, not at Greenwich!</span></td> <td style='padding: 10px;'>3D vectors on sphere:<br><code>(cos(lat)cos(lon), cos(lat)sin(lon), sin(lat))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>üì° Signal Phase</strong><br><code>œÜ ‚àà [‚àíœÄ, œÄ)</code></td> <td style='padding: 10px;'>Phase unwrapping creates artificial jumps<br><span style='color: #FF5722;'>Destroys true periodicity</span></td> <td style='padding: 10px;'>Complex: <code>e<sup>iœÜ</sup> = cos(œÜ) + i¬∑sin(œÜ)</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>üíç Ring Buffers</strong><br><code>idx ‚àà [0, size)</code></td> <td style='padding: 10px;'><code>tail - head</code> wrong when wrapped<br><span style='color: #FF5722;'>Buffer looks full when nearly empty!</span></td> <td style='padding: 10px;'><code>(idx + size) % size</code><br>or embed as angle</td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>‚öôÔ∏è Gear Teeth</strong><br><code>tooth ‚àà [0, N)</code></td> <td style='padding: 10px;'>Tooth 0 and Tooth N-1 look maximally apart<br><span style='color: #FF5722;'>They're actually neighbors!</span></td> <td style='padding: 10px;'><code>(cos(2œÄt/N), sin(2œÄt/N))</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>üß¨ Circadian Phase</strong><br><code>t ‚àà [0, 24h)</code></td> <td style='padding: 10px;'>Sleep at 23:00 and 01:00 averages to noon?<br><span style='color: #FF5722;'>Should be midnight!</span></td> <td style='padding: 10px;'><code>(cos(2œÄt/24), sin(2œÄt/24))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>üìä Months of Year</strong><br><code>m ‚àà {1..12}</code></td> <td style='padding: 10px;'>Dec(12) to Jan(1) = -11 months?<br><span style='color: #FF5722;'>Just 1 month forward!</span></td> <td style='padding: 10px;'><code>(cos(2œÄm/12), sin(2œÄm/12))</code></td> </tr> </tbody> </table> </div> <div class='highlight-box'> <h3>üí° The Universal Solution</h3> <div class='formula-showcase'> <p style='text-align: center; font-size: 18px; margin: 15px 0;'> <strong>For ANY cyclic quantity with period T starting at offset s:</strong> </p> <p style='text-align: center; font-size: 20px; background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px;'> <code>Œ∏ = 2œÄ(value - s)/T</code> ‚Üí <code>(cos(Œ∏), sin(Œ∏))</code> </p> <p style='text-align: center; margin-top: 15px;'> Do all your math in vector space, then project back if needed! </p> </div> </div> <div class='info-box'> <h3>üéØ When to Suspect a Hidden Ring</h3> <div class='two-column'> <div> <h4>üö© Red Flags in Your Data</h4> <ul> <li>Values that 'roll over' or 'wrap'</li> <li>Modulo operations in the code</li> <li>Special cases for 'crossing midnight'</li> <li>Discontinuous jumps in time series</li> <li>'Distance' that depends on direction</li> </ul> </div> <div> <h4>üêõ Classic Bug Patterns</h4> <ul> <li>Averages that are wildly wrong</li> <li>Interpolation that takes the 'long way'</li> <li>Derivatives with impossible spikes</li> <li>Sorting that puts neighbors far apart</li> <li>Clustering that splits natural groups</li> </ul> </div> </div> </div> </div>",

  "7": "<div class='slide'> <h1>When Zero Isn't Special: Arbitrary Wrap Points</h1> <div class='warning-box'> <h3>üéØ Real Hardware Doesn't Care About Zero</h3> <p>Many circular quantities in the wild wrap at arbitrary values, not nice round numbers. The math still works‚Äîyou just need to normalize first!</p> </div> <div class='two-column-equal'> <div class='card'> <h3>üìä Common Non-Zero Wrap Domains</h3> <div class='example-list'> <div class='example-item'> <h4>üß≠ Compass: [-180¬∞, +180¬∞)</h4> <p>Wraps at ¬±180¬∞, not 0¬∞/360¬∞</p> <code>bearing ‚àà [-180, 180)</code> </div> <div class='example-item'> <h4>üîß Rotary Encoder: [1000, 5096)</h4> <p>12-bit encoder with arbitrary offset</p> <code>counts ‚àà [1000, 5096)</code> </div> <div class='example-item'> <h4>üì° Phase: [-œÄ, +œÄ)</h4> <p>Centered around zero, not starting at it</p> <code>phase ‚àà [-œÄ, œÄ)</code> </div> <div class='example-item'> <h4>üóìÔ∏è Fiscal Year: [Apr, Mar]</h4> <p>Wraps at March/April boundary</p> <code>month ‚àà [4, 3] (mod 12)</code> </div> <div class='example-item'> <h4>üå°Ô∏è ADC Values: [512, 3584)</h4> <p>Sensor with DC offset and limited range</p> <code>adc ‚àà [512, 3584)</code> </div> </div> </div> <div class='card'> <h3>‚ú® The Universal Transform</h3> <div class='formula-showcase' style='background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;'> <h4>For any circular quantity:</h4> <p><code>value ‚àà [min, max)</code></p> <p style='margin: 15px 0;'>‚Üì</p> <p><strong>1. Normalize to [0, 1):</strong></p> <p><code>t = (value - min) / (max - min)</code></p> <p style='margin: 15px 0;'>‚Üì</p> <p><strong>2. Embed on unit circle:</strong></p> <p><code>v = (cos(2œÄt), sin(2œÄt))</code></p> <p style='margin: 15px 0;'>‚Üì</p> <p><strong>3. Do your math in ‚Ñù¬≤</strong></p> <p style='margin: 15px 0;'>‚Üì</p> <p><strong>4. Project back if needed:</strong></p> <p><code>result = min + (max-min) √ó atan2(v.y, v.x)/(2œÄ)</code></p> </div> </div> </div> <div class='success-box'> <h3>üíª Code Example: Averaging Compass Bearings</h3> <div class='code-example'> <pre><code class='language-python'># PROBLEM: Compass uses [-180¬∞, +180¬∞) not [0¬∞, 360¬∞)\nbearings = [170, 175, -175, -170]  # All pointing roughly south\n# WRONG: Simple average\nnaive_mean = np.mean(bearings)  # = 0¬∞ (North!) ü§¶\n# RIGHT: Normalize ‚Üí Embed ‚Üí Average ‚Üí Denormalize\ndef circular_mean(values, min_val, max_val):\n    # Step 1: Normalize to [0, 1)\n    period = max_val - min_val\n    normalized = [(v - min_val) / period for v in values]\n    \n    # Step 2: Embed on circle\n    vectors = [(np.cos(2*np.pi*t), np.sin(2*np.pi*t)) for t in normalized]\n    \n    # Step 3: Average in vector space\n    mean_vector = np.mean(vectors, axis=0)\n    \n    # Step 4: Project back to original domain\n    angle = np.atan2(mean_vector[1], mean_vector[0])\n    result = min_val + (angle / (2*np.pi)) * period\n    if result < min_val:\n        result += period\n    return result\ncorrect_mean = circular_mean(bearings, -180, 180)  # ‚âà 175¬∞ South! ‚úÖ</code></pre> </div> </div> <div class='info-box'> <h3>üîß Practical Examples</h3> <div class='three-column'> <div> <h4>üéÆ Game Development</h4> <div class='code-snippet'> <pre><code># Joystick angle ‚àà [-œÄ, œÄ]\njs_angle = atan2(js.y, js.x)\n# Don't compare directly!\n# Normalize first</code></pre> </div> </div> <div> <h4>ü§ñ Robotics</h4> <div class='code-snippet'> <pre><code># Encoder wraps at 8192\n# but starts at 1000\nactual_pos = 1000 + \n  (raw - 1000) % 7192</code></pre> </div> </div> <div> <h4>üìä Time Series</h4> <div class='code-snippet'> <pre><code># Fiscal quarters Q2-Q1\n# April = month 0\nfiscal_month = \n  (cal_month - 4) % 12</code></pre> </div> </div> </div> </div> <div class='highlight-box'> <h3>üéØ Key Insight</h3> <p style='font-size: 18px; text-align: center; margin: 20px 0;'> <strong>The 'zero point' is arbitrary!</strong> What matters is the <em>topology</em>‚Äîthat values wrap around. </p> <p style='text-align: center;'> Always normalize to [0, 1) or [0, 2œÄ) before embedding. Your vector math doesn't care where the original wrap point was. </p> </div> </div>",

  "8": "<div class='slide'> <h1>Real Example: Robot/Drone Heading Control</h1> <div class='problem-setup'> <h3>ü§ñ The Scenario</h3> <p>PID controller needs to turn robot from 350¬∞ to 10¬∞</p> </div> <div class='visual-comparison'> <div class='approach bad-approach'> <h4>‚ùå Naive PID Error</h4> <svg width='500' height='500' viewBox='0 0 250 250'> <circle cx='125' cy='125' r='100' fill='none' stroke='#333' stroke-width='2'/> <!-- Current heading: 350¬∞ --> <line x1='125' y1='125' x2='115' y2='25' stroke='#2196F3' stroke-width='4'/> <circle cx='115' cy='25' r='6' fill='#2196F3'/> <text x='75' y='15' font-size='12' fill='#FFC107'>Current: 350¬∞</text> <!-- Target heading: 10¬∞ --> <line x1='125' y1='125' x2='135' y2='25' stroke='#4CAF50' stroke-width='4'/> <circle cx='135' cy='25' r='6' fill='#4CAF50'/> <text x='175' y='15' font-size='12' fill='#FFC107'>Target: 10¬∞</text> <!-- Wrong rotation path --> <path d='M 115 25 A 100 100 0 1 1 135 25' fill='none' stroke='#FF5722' stroke-width='3' stroke-dasharray='5,5'/> <text x='125' y='200' text-anchor='middle' font-size='14' fill='#FF5722' font-weight='bold'> Error: -340¬∞ </text> <text x='125' y='220' text-anchor='middle' font-size='12' fill='#FF5722'> Spins backward! </text> </svg> <pre><code>error = target - current\nerror = 10 - 350 = -340¬∞\n# Robot spins almost full circle\n# the wrong way!</code></pre> </div> <div class='approach good-approach'> <h4>‚úÖ Embedded Solution</h4> <svg width='500' height='500' viewBox='0 0 250 250'> <circle cx='125' cy='125' r='100' fill='none' stroke='#333' stroke-width='2'/> <!-- Current heading: 350¬∞ --> <line x1='125' y1='125' x2='115' y2='25' stroke='#2196F3' stroke-width='4'/> <circle cx='115' cy='25' r='6' fill='#2196F3'/> <text x='75' y='15' font-size='12' fill='#FFC107'>Current: 350¬∞</text> <!-- Target heading: 10¬∞ --> <line x1='125' y1='125' x2='135' y2='25' stroke='#4CAF50' stroke-width='4'/> <circle cx='135' cy='25' r='6' fill='#4CAF50'/> <text x='175' y='15' font-size='12' fill='#FFC107'>Target: 10¬∞</text> <!-- Correct rotation path --> <path d='M 115 25 A 100 100 0 0 1 135 25' fill='none' stroke='#4CAF50' stroke-width='3'/> <text x='125' y='200' text-anchor='middle' font-size='14' fill='#4CAF50' font-weight='bold'> Error: +20¬∞ </text> <text x='125' y='220' text-anchor='middle' font-size='12' fill='#4CAF50'> Efficient turn! </text> </svg> <pre><code>def heading_error(current, target):\n    c_vec = [cos(current), sin(current)]\n    t_vec = [cos(target), sin(target)]\n    return atan2(cross(c_vec, t_vec), \n                 dot(c_vec, t_vec))\n# Returns: +20¬∞ (shortest path!)</code></pre> </div> </div> <div class='implementation'> <h3>Complete PID Controller Fix</h3> <pre><code class='language-python'>class HeadingController:\n    def __init__(self, kp=1.0, ki=0.1, kd=0.05):\n        self.kp, self.ki, self.kd = kp, ki, kd\n        self.integral = 0\n        self.last_error = 0\n        \n    def compute_control(self, current_heading, target_heading, dt):\n        # Embed both headings as vectors\n        current_vec = np.array([np.cos(current_heading), np.sin(current_heading)])\n        target_vec = np.array([np.cos(target_heading), np.sin(target_heading)])\n        \n        # Compute signed angle error (always shortest path)\n        error = np.arctan2(\n            current_vec[0] * target_vec[1] - current_vec[1] * target_vec[0],\n            current_vec[0] * target_vec[0] + current_vec[1] * target_vec[1]\n        )\n        \n        # Standard PID computation (now with correct error!)\n        self.integral += error * dt\n        derivative = (error - self.last_error) / dt\n        \n        control = self.kp * error + self.ki * self.integral + self.kd * derivative\n        self.last_error = error\n        \n        return control  # Angular velocity command</code></pre> </div> <div class='impact-note'> <p>üí∞ <strong>Real Impact:</strong> Shipping routes crossing the Pacific get drawn spanning ~359¬∞ longitude instead of the short ~20 nautical mile path due to antimeridian wraparound bugs in mapping SDKs</p> </div> </div>",

  "9": "<div class='slide'> <h1>Color Interpolation (HSV Hue)</h1> <div class='color-problem'> <h3>üé® The Problem: Fade from Red to Magenta</h3> <div class='color-display'> <div class='color-box' style='background: hsl(10, 100%, 50%);'> <span>Red<br>10¬∞</span> </div> <div class='arrow'>‚Üí</div> <div class='color-box' style='background: hsl(350, 100%, 50%);'> <span>Magenta<br>350¬∞</span> </div> </div> </div> <div class='approaches'> <div class='approach-bad'> <h4>‚ùå Linear Interpolation</h4> <div class='color-gradient bad-gradient'> <div class='color-step' style='background: hsl(10, 100%, 50%);'></div> <div class='color-step' style='background: hsl(68, 100%, 50%);'></div> <div class='color-step' style='background: hsl(126, 100%, 50%);'></div> <div class='color-step' style='background: hsl(180, 100%, 50%);'></div> <div class='color-step' style='background: hsl(238, 100%, 50%);'></div> <div class='color-step' style='background: hsl(296, 100%, 50%);'></div> <div class='color-step' style='background: hsl(350, 100%, 50%);'></div> </div> <pre><code>mid_hue = (10 + 350) / 2 = 180¬∞  # CYAN!?\n# Goes through entire rainbow!</code></pre> </div> <div class='approach-good'> <h4>‚úÖ Circular Interpolation</h4> <div class='color-gradient good-gradient'> <div class='color-step' style='background: hsl(10, 100%, 50%);'></div> <div class='color-step' style='background: hsl(6, 100%, 50%);'></div> <div class='color-step' style='background: hsl(2, 100%, 50%);'></div> <div class='color-step' style='background: hsl(358, 100%, 50%);'></div> <div class='color-step' style='background: hsl(354, 100%, 50%);'></div> <div class='color-step' style='background: hsl(350, 100%, 50%);'></div> </div> <pre><code>vec1 = [cos(10¬∞), sin(10¬∞)]\nvec2 = [cos(350¬∞), sin(350¬∞)]\nvec_mid = normalize((vec1 + vec2) / 2)\nmid_hue = atan2(vec_mid)  # 0¬∞ (stays red!)</code></pre> </div> </div> <div class='implementation-example'> <h3>Production-Ready Color Lerp</h3> <pre><code class='javascript'>function lerpHue(h1, h2, t) {\n    // Convert hues to radians\n    const theta1 = h1 * Math.PI / 180;\n    const theta2 = h2 * Math.PI / 180;\n    \n    // Embed on unit circle\n    const v1 = [Math.cos(theta1), Math.sin(theta1)];\n    const v2 = [Math.cos(theta2), Math.sin(theta2)];\n    \n    // Interpolate vectors\n    const vt = [\n        (1 - t) * v1[0] + t * v2[0],\n        (1 - t) * v1[1] + t * v2[1]\n    ];\n    \n    // Normalize and convert back\n    const norm = Math.sqrt(vt[0]**2 + vt[1]**2);\n    const thetaT = Math.atan2(vt[1]/norm, vt[0]/norm);\n    \n    return (thetaT * 180 / Math.PI + 360) % 360;\n}\n// CSS gradient generator\nfunction generateGradient(h1, h2, steps) {\n    const colors = [];\n    for (let i = 0; i <= steps; i++) {\n        const t = i / steps;\n        const h = lerpHue(h1, h2, t);\n        colors.push(`hsl(${h}, 100%, 50%)`);\n    }\n    return `linear-gradient(90deg, ${colors.join(', ')})`;\n}</code></pre> </div> <div class='use-cases'> <h3>Where This Matters</h3> <ul> <li>üéÆ <strong>Game UI:</strong> Health bar color transitions</li> <li>üìä <strong>Data Viz:</strong> Temperature/pressure heatmaps</li> <li>üé¨ <strong>Animation:</strong> Smooth color transitions</li> <li>üñºÔ∏è <strong>Image Processing:</strong> Color correction algorithms</li> </ul> </div> </div>",

  "10": "<div class='slide'> <h1>The General Pattern</h1> <div class='pattern-table'> <h3>Any Circular Quantity Can Be Embedded!</h3> <table> <thead> <tr> <th>Wraparound Quantity</th> <th>Traditional Problems</th> <th>Embedding Solution</th> <th>Benefits</th> </tr> </thead> <tbody> <tr> <td><strong>Angle</strong><br>Œ∏ ‚àà [0, 2œÄ)</td> <td>Gimbal lock, discontinuities</td> <td>(cos Œ∏, sin Œ∏) ‚àà ‚Ñù¬≤</td> <td>Smooth interpolation</td> </tr> <tr> <td><strong>Time of Day</strong><br>t ‚àà [0, 24)</td> <td>Midnight wraparound</td> <td>(cos 2œÄt/24, sin 2œÄt/24)</td> <td>No special cases</td> </tr> <tr> <td><strong>Day of Week</strong><br>d ‚àà {0..6}</td> <td>Weekend averaging</td> <td>e^(2œÄid/7) or 7D one-hot</td> <td>Correct statistics</td> </tr> <tr> <td><strong>Phase</strong><br>œÜ ‚àà [-œÄ, œÄ)</td> <td>Phase unwrapping</td> <td>e^(iœÜ) ‚àà ‚ÑÇ</td> <td>Natural operations</td> </tr> <tr> <td><strong>Encoder Position</strong><br>n ‚àà [0, 4096)</td> <td>Rollover detection</td> <td>(cos 2œÄn/4096, sin 2œÄn/4096)</td> <td>Continuous tracking</td> </tr> </tbody> </table> </div> <div class='universal-class'> <h3>One Class to Rule Them All</h3> <pre><code class='language-python'>class CircularQuantity:\n    '''Universal handler for any quantity that wraps around'''\n    \n    def __init__(self, value, period):\n        self.period = period\n        self.value = value % period  # Normalize to [0, period)\n        \n        # THE KEY: Embed on unit circle\n        theta = 2 * np.pi * self.value / period\n        self.vec = np.array([np.cos(theta), np.sin(theta)])\n    \n    def shortest_distance_to(self, other):\n        '''Always returns shortest signed distance'''\n        angle = np.arctan2(\n            self.vec[0] * other.vec[1] - self.vec[1] * other.vec[0],\n            self.vec[0] * other.vec[0] + self.vec[1] * other.vec[1]\n        )\n        return angle * self.period / (2 * np.pi)\n    \n    def average_with(self, others):\n        '''Proper circular mean'''\n        all_vecs = [self.vec] + [o.vec for o in others]\n        mean_vec = np.mean(all_vecs, axis=0)\n        mean_vec /= np.linalg.norm(mean_vec)  # Renormalize\n        \n        angle = np.arctan2(mean_vec[1], mean_vec[0])\n        mean_value = angle * self.period / (2 * np.pi)\n        return CircularQuantity(mean_value, self.period)\n    \n    def interpolate_to(self, other, t):\n        '''Smooth interpolation along shortest path'''\n        # SLERP for perfect circular interpolation\n        dot = np.dot(self.vec, other.vec)\n        omega = np.arccos(np.clip(dot, -1, 1))\n        \n        if abs(omega) < 1e-10:  # Vectors are identical\n            return self\n        \n        vec_t = (np.sin((1-t)*omega)/np.sin(omega) * self.vec +\n                 np.sin(t*omega)/np.sin(omega) * other.vec)\n        \n        angle = np.arctan2(vec_t[1], vec_t[0])\n        value = angle * self.period / (2 * np.pi)\n        return CircularQuantity(value, self.period)</code></pre> </div> <div class='examples-grid'> <div class='example'> <h4>üìê Angles</h4> <pre><code>a1 = CircularQuantity(350, 360)\na2 = CircularQuantity(10, 360)\ndist = a1.shortest_distance_to(a2)\n# Result: 20¬∞</code></pre> </div> <div class='example'> <h4>‚è∞ Time</h4> <pre><code>t1 = CircularQuantity(23.5, 24)\nt2 = CircularQuantity(0.5, 24)\navg = t1.average_with([t2])\n# Result: 0.0 (midnight)</code></pre> </div> <div class='example'> <h4>üìÖ Weekdays</h4> <pre><code>days = [CircularQuantity(6, 7),  # Sat\n        CircularQuantity(0, 7),  # Sun\n        CircularQuantity(1, 7)]  # Mon\navg = days[0].average_with(days[1:])\n# Result: 0 (Sunday)</code></pre> </div> <div class='example'> <h4>üîÑ Encoder</h4> <pre><code>e1 = CircularQuantity(4090, 4096)\ne2 = CircularQuantity(10, 4096)\ndelta = e1.shortest_distance_to(e2)\n# Result: 20 counts</code></pre> </div> </div> </div>",

  "11": "<div class='slide'> <h1>The Mathematical Insight</h1> <div class='info-box'> <h3>Why Does This Work?</h3> <div class='visual-demo'> <svg width='600' height='150' viewBox='0 0 600 150'> <!-- Line with endpoints --> <g transform='translate(100, 75)'> <line x1='-60' y1='0' x2='60' y2='0' stroke='#333' stroke-width='3'/> <circle cx='-60' cy='0' r='6' fill='#FF5722'/> <circle cx='60' cy='0' r='6' fill='#FF5722'/> <text x='0' y='30' text-anchor='middle' font-size='14' fill='#FFC107'>Line has endpoints</text> </g> <!-- vs --> <text x='300' y='80' text-anchor='middle' font-size='20' fill='#FFC107'>vs</text> <!-- Circle --> <g transform='translate(500, 40)'> <circle cx='0' cy='0' r='50' fill='none' stroke='#333' stroke-width='3'/> <text x='0' y='70' text-anchor='middle' font-size='14' fill='#FFC107'>Circle has none!</text> </g> </svg> </div> <p class='text-center'>A circle (S¬π) is topologically different from a line segment. Linear math breaks at the wraparound point.</p> </div> <div class='two-column-equal'> <div class='card'> <h3>üåê The Circle Problem</h3> <ul> <li><strong>Circles have no 'beginning' or 'end'</strong></li> <li>359¬∞ and 1¬∞ are neighbors</li> <li>But arithmetic says 359 - 1 = 358 ü§¶</li> <li>‚Üí Solution: Use 2D vectors instead!</li> </ul> </div> <div class='card'> <h3>üîÑ The Wrapping Function</h3> <svg width='300' height='120' viewBox='0 0 300 120'> <path d='M 20 80 Q 70 20, 120 80 T 220 80 T 280 80' stroke='#2196F3' stroke-width='3' fill='none'/> <text x='50' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>0¬∞</text> <text x='120' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>360¬∞</text> <text x='190' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>720¬∞</text> <text x='260' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>1080¬∞</text> </svg> <p>Angles wrap around: 370¬∞ = 10¬∞, 730¬∞ = 10¬∞, etc. The infinite line wraps onto the finite circle.</p> </div> </div> <div class='success-box'> <h3>üîë The Universal Pattern</h3> <div class='process-flow'> <div class='process-step'> <h4>Problem Space</h4> <p>Non-linear manifold</p> <small>(circle, sphere, torus)</small> </div> <div class='process-step'> <h4>Embedding</h4> <p>Lift to linear space</p> <small>(‚Ñù¬≤, ‚Ñù¬≥, ‚ÑÇ)</small> </div> <div class='process-step'> <h4>Computation</h4> <p>Do linear algebra</p> <small>(add, average, interpolate)</small> </div> <div class='process-step'> <h4>Projection</h4> <p>Map back to manifold</p> <small>(atan2, normalize)</small> </div> </div> </div> <div class='two-column'> <div class='warning-box'> <h3>üéØ Where Else This Appears</h3> <ul> <li><strong>Quaternions:</strong> 3D rotations in 4D space</li> <li><strong>Complex Numbers:</strong> 2D rotations in ‚ÑÇ</li> <li><strong>Fourier Transform:</strong> Signals on unit circle</li> <li><strong>Neural Networks:</strong> Learned embeddings</li> </ul> </div> <div class='highlight-box'> <h3>üí≠ Mathematical Insight</h3> <blockquote style='font-style: italic; margin: 10px 0;'> 'The introduction of numbers as coordinates is an act of violence.' <br><cite style='font-size: 14px;'>‚Äî Hermann Weyl</cite> </blockquote> <p><strong>But sometimes, the right coordinates make the violence worthwhile!</strong></p> </div> </div> </div>",

  "12": "<div class='slide'> <h1>Key Takeaways</h1> <div class='main-takeaway'> <h2>üéØ The Golden Rule</h2> <div class='golden-rule'> <p>When you see a quantity that wraps around,</p> <p><strong>ask: 'Can I embed this on a circle?'</strong></p> </div> </div> <div class='practical-steps'> <h3>Your Debugging Checklist</h3> <div class='checklist'> <div class='check-item'> <span class='checkbox'>‚úì</span> <div> <h4>Spot the Wraparound</h4> <p>Does your value jump discontinuously? (359¬∞ ‚Üí 0¬∞, 11:59 PM ‚Üí 12:00 AM)</p> </div> </div> <div class='check-item'> <span class='checkbox'>‚úì</span> <div> <h4>Identify the Period</h4> <p>What's the cycle length? (360¬∞ for angles, 24 hours for time, 7 for weekdays)</p> </div> </div> <div class='check-item'> <span class='checkbox'>‚úì</span> <div> <h4>Choose Your Embedding</h4> <p>Usually: <code style='display: inline-block;'>(cos(<span style='display: inline-block; vertical-align: middle;'><span style='display: block; text-align: center; border-bottom: 1px solid;'>2œÄx</span><span style='display: block; text-align: center;'>T</span></span>), sin(<span style='display: inline-block; vertical-align: middle;'><span style='display: block; text-align: center; border-bottom: 1px solid;'>2œÄx</span><span style='display: block; text-align: center;'>T</span></span>))</code> where <code>T</code> is the period</p> </div> </div> <div class='check-item'> <span class='checkbox'>‚úì</span> <div> <h4>Work in Vector Space</h4> <p>Do all math on the vectors, not the raw values</p> </div> </div> <div class='check-item'> <span class='checkbox'>‚úì</span> <div> <h4>Project Back When Needed</h4> <p>Use <code>atan2(y, x)</code> to recover the original quantity</p> </div> </div> </div> </div> <div class='libraries-section'> <h3>Don't Reinvent: Use Libraries!</h3> <div class='library-grid'> <div class='library'> <h4>Python</h4> <ul> <li><code>scipy.stats.circmean</code></li> <li><code>astropy.coordinates</code></li> <li><code>pyquaternion</code></li> </ul> </div> <div class='library'> <h4>JavaScript</h4> <ul> <li><code>d3-interpolate</code></li> <li><code>three.js Quaternion</code></li> <li><code>tinycolor2</code></li> </ul> </div> <div class='library'> <h4>C++</h4> <ul> <li><code>Eigen::AngleAxis</code></li> <li><code>boost::geometry</code></li> <li><code>tf2</code> (ROS)</li> </ul> </div> <div class='library'> <h4>MATLAB</h4> <ul> <li><code>circstat toolbox</code></li> <li><code>Aerospace Toolbox</code></li> <li><code>angle()</code>, <code>unwrap()</code></li> </ul> </div> </div> </div> <div class='red-flags'> <h3>üö© Red Flags in Your Code</h3> <div class='flag-list'> <div class='flag'> <code>if (angle > 180) angle -= 360;</code> <span>‚Üí Use circular math instead</span> </div> <div class='flag'> <code>if (crossed_midnight) /* special case */</code> <span>‚Üí Embed on 24-hour circle</span> </div> <div class='flag'> <code>while (phase > œÄ) phase -= 2œÄ;</code> <span>‚Üí Work with complex exponentials</span> </div> <div class='flag'> <code>// TODO: handle wraparound</code> <span>‚Üí Today's the day!</span> </div> </div> </div> <div class='success-story'> <div class='story-content'> <h3>üéâ Success Story</h3> <p>'After this talk, I fixed a 3-year-old GPS bearing bug in 5 lines of code. The robot finally drives in straight lines!'</p> <cite>‚Äî Future You</cite> </div> </div> </div>",

  "13": "<div class='slide'> <h1>Interactive Demo</h1> <div class='demo-container'> <div class='demo-section'> <h3>üéÆ Try It Yourself: Angle Averaging</h3> <div class='angle-inputs'> <label> Angle 1: <input type='range' id='angle1' min='0' max='359' value='350'> <span id='angle1-display'>350¬∞</span> </label> <label> Angle 2: <input type='range' id='angle2' min='0' max='359' value='10'> <span id='angle2-display'>10¬∞</span> </label> </div> <div class='demo-visual'> <svg width='400' height='400' viewBox='0 0 400 400' id='demo-svg'> <!-- Circle --> <circle cx='200' cy='200' r='150' fill='none' stroke='#333' stroke-width='2'/> <!-- Compass labels --> <text x='200' y='30' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>0¬∞</text> <text x='370' y='205' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>90¬∞</text> <text x='200' y='380' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>180¬∞</text> <text x='30' y='205' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>270¬∞</text> <!-- Angle 1 line --> <line id='angle1-line' x1='200' y1='200' x2='200' y2='50' stroke='#2196F3' stroke-width='4'/> <circle id='angle1-point' cx='200' cy='50' r='8' fill='#2196F3'/> <!-- Angle 2 line --> <line id='angle2-line' x1='200' y1='200' x2='200' y2='50' stroke='#4CAF50' stroke-width='4'/> <circle id='angle2-point' cx='200' cy='50' r='8' fill='#4CAF50'/> <!-- Average (wrong) --> <line id='avg-wrong-line' x1='200' y1='200' x2='200' y2='350' stroke='#FF5722' stroke-width='3' stroke-dasharray='5,5' opacity='0'/> <circle id='avg-wrong-point' cx='200' cy='350' r='6' fill='#FF5722' opacity='0'/> <!-- Average (correct) --> <line id='avg-correct-line' x1='200' y1='200' x2='200' y2='50' stroke='#FFC107' stroke-width='4'/> <circle id='avg-correct-point' cx='200' cy='50' r='8' fill='#FFC107'/> </svg> </div> <div class='demo-results'> <div class='result wrong-result'> <h4>‚ùå Linear Average</h4> <p id='wrong-result'>180¬∞</p> </div> <div class='result correct-result'> <h4>‚úÖ Circular Average</h4> <p id='correct-result'>0¬∞</p> </div> </div> </div> <div class='code-section'> <h3>The Code Behind It</h3> <pre><code id='demo-code'>function circularAverage(a1, a2) {\n    // Convert to radians\n    const theta1 = a1 * Math.PI / 180;\n    const theta2 = a2 * Math.PI / 180;\n    \n    // Embed on unit circle\n    const v1 = [Math.cos(theta1), Math.sin(theta1)];\n    const v2 = [Math.cos(theta2), Math.sin(theta2)];\n    \n    // Average vectors\n    const avgVec = [(v1[0] + v2[0])/2, (v1[1] + v2[1])/2];\n    \n    // Convert back to angle\n    const avgTheta = Math.atan2(avgVec[1], avgVec[0]);\n    return (avgTheta * 180 / Math.PI + 360) % 360;\n}</code></pre> </div> </div> </div>",

  "14": "<div class='slide' style='display:grid; gap:12px;'> <h1>üåç GIS Demo: Longitude Wraparound at the International Date Line</h1> <div class='info-box'> <h3>Real-World Problem: Computing Geographic Means</h3> <p>When averaging GPS coordinates near ¬±180¬∞ longitude (International Date Line), linear arithmetic fails spectacularly. A farm field split by the date line appears to span the entire globe!</p> </div> <div id='map' style='height:600px; border-radius:12px; overflow:hidden; border:1px solid rgba(255,255,255,.15)'></div> <div style='display:flex; gap:16px; flex-wrap:wrap; align-items:center;'> <label><input type='checkbox' id='worldCopy' checked> worldCopyJump (wrap world)</label> <label><input type='checkbox' id='noWrapTiles'> tile noWrap (stop wrapping tiles)</label> <span id='readout' style='opacity:.9; font-family: monospace;'>Circular mean: ‚Ä¶</span> </div> <div class='success-box'> <h3>üéØ Try This: Drag the markers across the International Date Line!</h3> <p><strong>Red marker</strong> = Wrong linear mean | <strong>Green marker</strong> = Correct circular mean</p> <p>Watch how the linear mean jumps to the middle of the Atlantic while the circular mean stays put! This is the classic longitude wraparound bug.</p> </div> <div class='code-example'> <h3>Spherical Coordinate Embedding</h3> <pre><code class='language-python'># For full lat/long geometry operations\ndef latlon_to_cartesian(lat, lon):\n    '''Embed (lat,lon) in R¬≥ for linear operations'''\n    lat_rad = np.radians(lat)\n    lon_rad = np.radians(lon)\n    return np.array([\n        np.cos(lat_rad) * np.cos(lon_rad),  # x\n        np.cos(lat_rad) * np.sin(lon_rad),  # y  \n        np.sin(lat_rad)                     # z\n    ])\n# Geographic centroid (works across antimeridian!)\ndef geographic_centroid(lat_lon_pairs):\n    cartesian_points = [latlon_to_cartesian(lat, lon) \n                       for lat, lon in lat_lon_pairs]\n    mean_cartesian = np.mean(cartesian_points, axis=0)\n    mean_cartesian /= np.linalg.norm(mean_cartesian)  # Back to unit sphere\n    \n    # Convert back to lat/lon\n    lat = np.degrees(np.arcsin(mean_cartesian[2]))\n    lon = np.degrees(np.arctan2(mean_cartesian[1], mean_cartesian[0]))\n    return lat, lon</code></pre> </div> <div class='warning-box'> <h3>üè¢ Company Applications</h3> <ul> <li><strong>Spatial Statistics:</strong> Computing true centroids for service areas</li> <li><strong>Route Optimization:</strong> Distance calculations that work globally</li> <li><strong>Geofencing:</strong> Boundary checks that don't break at meridians</li> <li><strong>Data Quality:</strong> Detecting GPS outliers using proper spherical distance</li> </ul> </div> </div>"

};

// Include the unified presentation.js code
// Slide configuration - add slide filenames here in order
const slideFiles = [
    'slides/01-title.html',
    'slides/02-the-bug.html',
    'slides/03-midnight-bug.html', 
    'slides/04-the-solution.html',
    'slides/13-circular-statistics.html',
    'slides/14-discrete-calculus.html',
    'slides/15-other-circular-quantities.html',
    'slides/16-arbitrary-wrap-points.html',
    'slides/05-robot-heading.html',
    'slides/06-color-interpolation.html',
    'slides/07-general-pattern.html',
    'slides/08-mathematical-insight.html',
    'slides/09-takeaways.html',
    'slides/11-interactive-demo.html',
    'slides/12-gis-demo.html',
    'slides/16-vector-calculator.html',
    'slides/17-timeseries-analyzer.html',
    'slides/10-questions.html'
];

let currentSlide = 0;
let slidesLoaded = false;

// Global interactive app manager
window.currentInteractiveApp = null;

// Get total number of slides (from embedded data or file list)
const totalSlides = window.slideData ? Object.keys(window.slideData).length : slideFiles.length;

// Load slide content (either from embedded data or fetch)
async function loadSlide(index) {
    if (index < 0 || index >= totalSlides) return;
    
    // Clean up any existing interactive app
    if (window.currentInteractiveApp) {
        window.currentInteractiveApp.destroy(true, { children: true, texture: true, baseTexture: true });
        window.currentInteractiveApp = null;
    }
    
    try {
        let content;
        
        // Check if we have embedded slide data (bundled version)
        if (window.slideData) {
            content = window.slideData[index.toString()];
            if (!content) {
                throw new Error(`Slide data not found for key: ${index}`);
            }
        } else {
            // Fetch individual slide files (bundle folder version)
            const response = await fetch(slideFiles[index]);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            content = await response.text();
        }
        
        document.getElementById('slide-content').innerHTML = content;
        
        // Ensure code blocks have proper language classes and highlight syntax
        const slideContent = document.getElementById('slide-content');
        
        // Fix code classes for Highlight.js compatibility
        slideContent.querySelectorAll('pre code').forEach(el => {
            const cls = el.getAttribute('class') || '';
            if (/\bpython\b/i.test(cls) && !/\blanguage-python\b/i.test(cls)) {
                el.className = (cls + ' language-python').trim();
            }
            if (/\bjavascript\b/i.test(cls) && !/\blanguage-javascript\b/i.test(cls)) {
                el.className = (cls + ' language-javascript').trim();
            }
        });

        // Initialize demos based on slide content
        console.log('üîç Checking slide for interactive elements...');
        
        // Check if this is the interactive demo slide (look for the svg element)
        if (slideContent.querySelector('#demo-svg')) {
            console.log('üéÆ Interactive Demo slide detected, initializing...');
            console.log('initInteractiveDemo function exists:', typeof initInteractiveDemo);
            setTimeout(initInteractiveDemo, 100);
        }
        
        // Check if this is the GIS demo slide (look for the map container)
        if (slideContent.querySelector('#map')) {
            console.log('üó∫Ô∏è  GIS Demo slide detected, initializing...');
            console.log('initGISDemo function exists:', typeof initGISDemo);
            setTimeout(initGISDemo, 100);
        }
        
        // Check if this is the Vector Calculator slide
        if (slideContent.querySelector('#vector-calculator-container')) {
            console.log('üßÆ Vector Calculator slide detected, initializing...');
            console.log('initVectorCalculator function exists:', typeof initVectorCalculator);
            setTimeout(initVectorCalculator, 100);
        }
        
        // Check if this is the Time Series Analyzer slide
        if (slideContent.querySelector('#timeseries-analyzer-container')) {
            console.log('üìà Time Series Analyzer slide detected, initializing...');
            console.log('initTimeSeriesAnalyzer function exists:', typeof initTimeSeriesAnalyzer);
            setTimeout(initTimeSeriesAnalyzer, 100);
        }
        
        // Re-run Highlight.js on the new content
        if (window.hljs) {
            slideContent.querySelectorAll('pre code').forEach(block => {
                hljs.highlightElement(block);
            });
        }
        
        // Add fade in animation
        slideContent.style.animation = 'none';
        slideContent.offsetHeight; // Trigger reflow
        slideContent.style.animation = 'fadeIn 0.5s';

        // Dispatch custom event for SVG layout fixing
        window.dispatchEvent(new CustomEvent('slideLoaded'));

    } catch (error) {
        console.error('Error loading slide:', error);
        document.getElementById('slide-content').innerHTML = `
            <h1>Error Loading Slide</h1>
            <p>Could not load slide: ${slideFiles[index]}</p>
            <p>Error: ${error.message}</p>
        `;
    }
}

function updateNavigation() {
    const prevButton = document.querySelector('.nav-button');
    const nextButton = document.querySelector('.nav-button:last-child');
    
    // Never disable buttons since we wrap around
    prevButton.disabled = false;
    nextButton.disabled = false;
    
    document.getElementById('current-slide').textContent = currentSlide + 1;
    document.getElementById('total-slides').textContent = totalSlides;
}

function nextSlide() {
    if (currentSlide < totalSlides - 1) {
        currentSlide++;
    } else {
        currentSlide = 0; // Wrap to first slide
    }
    loadSlide(currentSlide);
    updateNavigation();
}

function previousSlide() {
    if (currentSlide > 0) {
        currentSlide--;
    } else {
        currentSlide = totalSlides - 1; // Wrap to last slide
    }
    loadSlide(currentSlide);
    updateNavigation();
}

// Jump to specific slide (for development/testing)
function goToSlide(index) {
    if (index >= 0 && index < totalSlides) {
        currentSlide = index;
        loadSlide(currentSlide);
        updateNavigation();
    }
}

// Keyboard navigation
document.addEventListener('keydown', function(event) {
    if (event.key === 'ArrowRight' || event.key === ' ') {
        event.preventDefault();
        nextSlide();
    } else if (event.key === 'ArrowLeft') {
        event.preventDefault();
        previousSlide();
    } else if (event.key >= '1' && event.key <= '9') {
        // Jump to slide by number key
        const slideNum = parseInt(event.key) - 1;
        if (slideNum < totalSlides) {
            goToSlide(slideNum);
        }
    } else if (event.key === 'Home') {
        goToSlide(0);
    } else if (event.key === 'End') {
        goToSlide(totalSlides - 1);
    }
});

// Wait for libraries and initialize presentation
function waitForLibrariesAndInit() {
    let attempts = 0;
    const maxAttempts = 50; // 5 seconds max

    const checkLibraries = setInterval(() => {
        attempts++;

        // Check if D3 and fc are loaded
        if (typeof window.d3 !== 'undefined' && typeof window.fc !== 'undefined') {
            clearInterval(checkLibraries);
            console.log('‚úÖ D3 and fc libraries loaded successfully');
            console.log('   D3 version:', d3.version);
            console.log('   fc.layoutLabel available:', typeof fc.layoutLabel === 'function');

            // Initialize presentation
            loadSlide(0);
            updateNavigation();
            slidesLoaded = true;

            // Add some helpful keyboard shortcuts info
            console.log('Keyboard shortcuts:');
            console.log('‚Üí or Space: Next slide');
            console.log('‚Üê: Previous slide');
            console.log('1-9: Jump to slide');
            console.log('Home: First slide');
            console.log('End: Last slide');
        } else if (attempts >= maxAttempts) {
            clearInterval(checkLibraries);
            console.warn('‚ö†Ô∏è D3/fc libraries failed to load after', attempts, 'attempts');
            console.warn('   Continuing without SVG layout fixing...');

            // Initialize presentation anyway
            loadSlide(0);
            updateNavigation();
            slidesLoaded = true;
        } else if (attempts % 10 === 0) {
            console.log('‚è≥ Waiting for D3/fc libraries... attempt', attempts);
        }
    }, 100);
}

// Initialize presentation
document.addEventListener('DOMContentLoaded', waitForLibrariesAndInit);

// Interactive demo functionality for slide 10
function initInteractiveDemo() {
    const angle1Input = document.getElementById('angle1');
    const angle2Input = document.getElementById('angle2');
    const angle1Display = document.getElementById('angle1-display');
    const angle2Display = document.getElementById('angle2-display');
    const wrongResult = document.getElementById('wrong-result');
    const correctResult = document.getElementById('correct-result');
    
    // Check if elements exist (safety check)
    if (!angle1Input || !angle2Input) {
        console.log('Interactive demo elements not found');
        return;
    }
    
    function updateDemo() {
        const a1 = parseInt(angle1Input.value);
        const a2 = parseInt(angle2Input.value);
        
        // Update displays
        angle1Display.textContent = a1 + '¬∞';
        angle2Display.textContent = a2 + '¬∞';
        
        // Calculate wrong (linear) average
        const wrongAvg = (a1 + a2) / 2;
        wrongResult.textContent = Math.round(wrongAvg) + '¬∞';
        
        // Calculate correct (circular) average
        const theta1 = a1 * Math.PI / 180;
        const theta2 = a2 * Math.PI / 180;
        const v1 = [Math.cos(theta1), Math.sin(theta1)];
        const v2 = [Math.cos(theta2), Math.sin(theta2)];
        const avgVec = [(v1[0] + v2[0])/2, (v1[1] + v2[1])/2];
        const norm = Math.sqrt(avgVec[0]**2 + avgVec[1]**2);
        avgVec[0] /= norm; avgVec[1] /= norm;
        const correctAvg = Math.atan2(avgVec[1], avgVec[0]) * 180 / Math.PI;
        const correctAvgNormalized = (correctAvg + 360) % 360;
        correctResult.textContent = Math.round(correctAvgNormalized) + '¬∞';
        
        // Update visual
        updateVisual(a1, a2, wrongAvg, correctAvgNormalized);
        
        // Show/hide wrong result based on how wrong it is
        const wrongness = Math.abs(wrongAvg - correctAvgNormalized);
        const adjustedWrongness = Math.min(wrongness, 360 - wrongness);
        const opacity = adjustedWrongness > 30 ? 1 : 0;
        
        const wrongLine = document.getElementById('avg-wrong-line');
        const wrongPoint = document.getElementById('avg-wrong-point');
        if (wrongLine) wrongLine.style.opacity = opacity;
        if (wrongPoint) wrongPoint.style.opacity = opacity;
    }
    
    function updateVisual(a1, a2, wrongAvg, correctAvg) {
        const cx = 200, cy = 200, r = 150;
        
        // Convert angles to positions
        function angleToPos(angle) {
            const rad = (angle - 90) * Math.PI / 180; // -90 to start from top
            return {
                x: cx + r * Math.cos(rad),
                y: cy + r * Math.sin(rad)
            };
        }
        
        const pos1 = angleToPos(a1);
        const pos2 = angleToPos(a2);
        const wrongPos = angleToPos(wrongAvg);
        const correctPos = angleToPos(correctAvg);
        
        // Update lines and points safely
        const elements = [
            { id: 'angle1-line', x2: pos1.x, y2: pos1.y },
            { id: 'angle1-point', cx: pos1.x, cy: pos1.y },
            { id: 'angle2-line', x2: pos2.x, y2: pos2.y },
            { id: 'angle2-point', cx: pos2.x, cy: pos2.y },
            { id: 'avg-wrong-line', x2: wrongPos.x, y2: wrongPos.y },
            { id: 'avg-wrong-point', cx: wrongPos.x, cy: wrongPos.y },
            { id: 'avg-correct-line', x2: correctPos.x, y2: correctPos.y },
            { id: 'avg-correct-point', cx: correctPos.x, cy: correctPos.y }
        ];
        
        elements.forEach(elem => {
            const element = document.getElementById(elem.id);
            if (element) {
                if (elem.x2 !== undefined) element.setAttribute('x2', elem.x2);
                if (elem.y2 !== undefined) element.setAttribute('y2', elem.y2);
                if (elem.cx !== undefined) element.setAttribute('cx', elem.cx);
                if (elem.cy !== undefined) element.setAttribute('cy', elem.cy);
            }
        });
    }
    
    // Set up event listeners
    angle1Input.addEventListener('input', updateDemo);
    angle2Input.addEventListener('input', updateDemo);
    
    // Initial update
    updateDemo();
    
    console.log('Interactive demo initialized');
}

// GIS Demo functionality for slide 12
function initGISDemo() {
    // Check if Leaflet is loaded
    if (typeof L === 'undefined') {
        console.log('Leaflet not loaded yet, retrying...');
        setTimeout(initGISDemo, 200);
        return;
    }
    
    // Check if map container exists
    const mapContainer = document.getElementById('map');
    if (!mapContainer) {
        console.log('Map container not found');
        return;
    }
    
    // Clear any existing map
    if (window.gisMap) {
        window.gisMap.remove();
        window.gisMap = null;
    }
    
    try {
        // International Date Line area (where the real wraparound happens)
        const DATELINE_CENTER = [0.0, 180.0]; // Equator at 180¬∞ longitude

        // Map with world copy jump disabled initially, centered on the International Date Line
        const map = L.map('map', { 
            center: DATELINE_CENTER, 
            zoom: 4, 
            worldCopyJump: false 
        });
        window.gisMap = map; // Store reference for cleanup

        // OSM tiles with attribution
        let tiles = L.tileLayer(
            'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            { 
                maxZoom: 19, 
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' 
            }
        ).addTo(map);
        window.gisTiles = tiles;

        // Two draggable points that straddle the International Date Line (the REAL wraparound!)
        const blueIcon = L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#2196F3; width:20px; height:20px; border-radius:50%; border:3px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.3);"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        const orangeIcon = L.divIcon({
            className: 'custom-marker', 
            html: '<div style="background:#FF9800; width:20px; height:20px; border-radius:50%; border:3px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.3);"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        
        const marker1 = L.marker([5.0, 175.0], {draggable:true, icon: blueIcon}).addTo(map).bindTooltip('+175¬∞E', {permanent:true, direction:'right'});
        const marker2 = L.marker([15.0, 178.0], {draggable:true, icon: orangeIcon}).addTo(map).bindTooltip('+178¬∞E', {permanent:true, direction:'left'});
        const pts = [marker1, marker2];
        window.gisMarkers = pts;
        
        console.log('Created GIS markers:', pts.length, 'markers at positions:', 
                   pts.map(m => `${m.getLatLng().lat},${m.getLatLng().lng}`));

        // Circular mean helper function
        function meanLonDeg(ds) {
            let x = 0, y = 0;
            for (const d of ds) {
                const r = d * Math.PI / 180;
                x += Math.cos(r); 
                y += Math.sin(r);
            }
            let m = Math.atan2(y, x) * 180 / Math.PI;
            if (m >= 180) m -= 360;
            if (m < -180) m += 360;
            return m;
        }

        // Result markers - RED for wrong, GREEN for correct
        const wrongMarker = L.circleMarker(DATELINE_CENTER, {
            radius: 12, 
            color: '#FF1744', 
            fillColor: '#FF5252', 
            fillOpacity: 0.9,
            weight: 3
        }).addTo(map).bindTooltip('WRONG: Linear Mean', {permanent: false, direction: 'top'});
        
        const correctMarker = L.circleMarker(DATELINE_CENTER, {
            radius: 15, 
            color: '#00C853', 
            fillColor: '#00E676', 
            fillOpacity: 0.9,
            weight: 3
        }).addTo(map).bindTooltip('CORRECT: Circular Mean', {permanent: false, direction: 'bottom'});
        const readout = document.getElementById('readout');
        
        window.gisResultMarkers = [wrongMarker, correctMarker];

        function update() {
            const lats = pts.map(m => m.getLatLng().lat);
            const lons = pts.map(m => m.getLatLng().lng);
            const latAvg = lats.reduce((a, b) => a + b, 0) / lats.length;
            const linMean = (lons[0] + lons[1]) / 2; // WRONG near 0¬∞
            const circMean = meanLonDeg(lons);

            wrongMarker.setLatLng([latAvg, linMean]);
            correctMarker.setLatLng([latAvg, circMean]);

            // Tiny line showing crossing at 0¬∞ 
            if (window.crossLine) map.removeLayer(window.crossLine);
            window.crossLine = L.polyline([[latAvg, -0.01], [latAvg, 0.01]], {color:'#4FC3F7', weight:3}).addTo(map);

            if (readout) {
                readout.textContent = 
                    `Circular mean: ${circMean.toFixed(3)}¬∞, Linear mean (wrong): ${((linMean + 540) % 360 - 180).toFixed(3)}¬∞`;
            }
        }

        pts.forEach(m => m.on('drag dragend', update));
        update();

        // UI toggles
        const worldCopyCheckbox = document.getElementById('worldCopy');
        const noWrapTilesCheckbox = document.getElementById('noWrapTiles');
        
        if (worldCopyCheckbox) {
            worldCopyCheckbox.addEventListener('change', (e) => {
                map.options.worldCopyJump = !!e.target.checked;
                map.panBy([1, 0]); // nudge to apply visually
            });
        }
        
        if (noWrapTilesCheckbox) {
            noWrapTilesCheckbox.addEventListener('change', (e) => {
                const noWrap = !!e.target.checked;
                map.removeLayer(tiles);
                tiles = L.tileLayer(
                    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    { 
                        maxZoom: 19, 
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors', 
                        noWrap 
                    }
                ).addTo(map);
                window.gisTiles = tiles;
            });
        }

        console.log('GIS demo initialized');
    } catch (error) {
        console.error('Error initializing GIS demo:', error);
    }
}



// Vector Calculator Interactive Demo
// Visualizes vector addition and subtraction using angle representation

console.log('üßÆ VECTOR CALCULATOR: JavaScript file loaded!');

// GLSL Fragment Shader for atan2 background visualization
const atan2FragmentShader = `
precision mediump float;
uniform vec2 u_resolution;
uniform float u_basis;
uniform float u_step_deg;
uniform float u_contour_alpha;

// Convert HSL to RGB
vec3 hsl2rgb(float h, float s, float l) {
    float c = (1.0 - abs(2.0 * l - 1.0)) * s;
    float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
    float m = l - c / 2.0;
    
    vec3 rgb;
    if (h < 1.0/6.0) {
        rgb = vec3(c, x, 0.0);
    } else if (h < 2.0/6.0) {
        rgb = vec3(x, c, 0.0);
    } else if (h < 3.0/6.0) {
        rgb = vec3(0.0, c, x);
    } else if (h < 4.0/6.0) {
        rgb = vec3(0.0, x, c);
    } else if (h < 5.0/6.0) {
        rgb = vec3(x, 0.0, c);
    } else {
        rgb = vec3(c, 0.0, x);
    }
    
    return rgb + m;
}

void main() {
    vec2 centered_coord = gl_FragCoord.xy - u_resolution / 2.0;
    float raw_angle = atan(centered_coord.y, centered_coord.x);
    
    // Apply basis rotation - this makes the field rotate with operations
    float angle = raw_angle - u_basis;
    
    // Map angle from [-PI, PI] to [0, 1] for hue
    float hue = (angle + 3.14159265) / (2.0 * 3.14159265);
    
    // Create radial gradient for better visualization
    float distance = length(centered_coord) / min(u_resolution.x, u_resolution.y) * 2.0;
    float lightness = 0.3 + 0.4 * (1.0 - min(distance, 1.0));
    
    // Add contour lines (isogons) for better geometric understanding
    float step_rad = u_step_deg * 3.14159265 / 180.0;
    float contour_dist = abs(mod(angle + 3.14159265, step_rad) - step_rad * 0.5);
    float contour_line = 1.0 - smoothstep(0.0, 0.02, contour_dist);
    
    vec3 base_color = hsl2rgb(hue, 0.8, lightness);
    vec3 contour_color = mix(base_color, vec3(1.0), contour_line * u_contour_alpha);
    
    gl_FragColor = vec4(contour_color, 1.0);
}
`;

// Global state for the vector calculator
let vectorCalculatorState = {
    p1_angle: 0.0,
    p2_angle: Math.PI / 4,
    operationMode: 'addition'
};

function initVectorCalculator() {
    console.log('üßÆ VECTOR CALCULATOR: Function called!');
    console.log('üßÆ VECTOR CALCULATOR: Initializing Vector Calculator...');
    console.log('üßÆ VECTOR CALCULATOR: Current state:', vectorCalculatorState);
    
    // Check if PIXI is loaded
    if (typeof PIXI === 'undefined') {
        console.log('PIXI not loaded yet, retrying...');
        setTimeout(initVectorCalculator, 200);
        return;
    }
    
    const container = document.getElementById('vector-calculator-container');
    if (!container) {
        console.log('Vector calculator container not found');
        return;
    }
    
    // Clean up any existing app for this specific container
    window.interactiveApps ??= new Map();
    const key = container.id;
    const existingApp = window.interactiveApps.get(key);
    if (existingApp) {
        existingApp.destroy(true, { children: true, texture: true, baseTexture: true });
        window.interactiveApps.delete(key);
    }
    
    // Check if container is visible and has dimensions
    if (container.offsetWidth === 0 || container.offsetHeight === 0) {
        console.log('Container not visible yet, retrying...');
        setTimeout(() => initVectorCalculator(), 100);
        return;
    }
    
    // Create PIXI application
    const app = new PIXI.Application({
        width: container.offsetWidth,
        height: container.offsetHeight,
        backgroundColor: 0x000000,
        antialias: true
    });
    
    container.appendChild(app.view);
    window.interactiveApps.set(key, app);
    
    // Create background layer for atan2 filter
    const backgroundLayer = new PIXI.Graphics();
    backgroundLayer.beginFill(0x000000);
    backgroundLayer.drawRect(0, 0, app.screen.width, app.screen.height);
    backgroundLayer.endFill();
    app.stage.addChild(backgroundLayer);
    
    // Create custom filter for atan2 background
    const atan2Filter = new PIXI.Filter(undefined, atan2FragmentShader, {
        u_resolution: [app.screen.width, app.screen.height],
        u_basis: 0.0,
        u_step_deg: 15.0,
        u_contour_alpha: 0.3
    });
    
    // Apply background filter only to background layer
    backgroundLayer.filterArea = app.screen;
    backgroundLayer.filters = [atan2Filter];
    
    // Create graphics objects on top of background
    const graphics = new PIXI.Graphics();
    app.stage.addChild(graphics);
    
    // Interactive state
    let isDragging = false;
    let dragTarget = null;
    
    // Make stage interactive (PIXI v7 API)
    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;
    app.stage.cursor = 'crosshair';
    
    console.log('üßÆ Interactive setup - eventMode:', app.stage.eventMode, 'hitArea:', app.stage.hitArea);
    
    // Drawing function
    function draw() {
        graphics.clear();
        
        // Remove old text objects
        app.stage.children = app.stage.children.filter(child => !(child instanceof PIXI.Text));
        
        // Update the field basis to show the operation in action
        // In addition mode: field rotates by p2_angle showing Œ∏ ‚Ü¶ Œ∏ + p2
        // In subtraction mode: field rotates by p2_angle showing Œ∏ ‚Ü¶ Œ∏ - p2
        atan2Filter.uniforms.u_basis = vectorCalculatorState.p2_angle;
        
        const centerX = app.screen.width / 2;
        const centerY = app.screen.height / 2;
        const radius = Math.min(centerX, centerY) * 0.7;
        
        // Draw unit circle with high contrast
        graphics.lineStyle(4, 0xFFFFFF, 1.0);
        graphics.drawCircle(centerX, centerY, radius);
        
        // Calculate positions
        const p1x = centerX + Math.cos(vectorCalculatorState.p1_angle) * radius;
        const p1y = centerY + Math.sin(vectorCalculatorState.p1_angle) * radius;
        const p2x = centerX + Math.cos(vectorCalculatorState.p2_angle) * radius;
        const p2y = centerY + Math.sin(vectorCalculatorState.p2_angle) * radius;
        
        // Draw vectors with high contrast outlines for visibility against atan2 background
        // Vector 1 (red) with white outline
        graphics.lineStyle(10, 0xFFFFFF, 1.0);
        graphics.moveTo(centerX, centerY);
        graphics.lineTo(p1x, p1y);
        graphics.lineStyle(6, 0xFF3333, 1.0);
        graphics.moveTo(centerX, centerY);
        graphics.lineTo(p1x, p1y);
        
        // Vector 2 (cyan) with white outline  
        graphics.lineStyle(10, 0xFFFFFF, 1.0);
        graphics.moveTo(centerX, centerY);
        graphics.lineTo(p2x, p2y);
        graphics.lineStyle(6, 0x33CCCC, 1.0);
        graphics.moveTo(centerX, centerY);
        graphics.lineTo(p2x, p2y);
        
        // Draw result based on operation mode with high contrast
        if (vectorCalculatorState.operationMode === 'addition') {
            const resultAngle = vectorCalculatorState.p1_angle + vectorCalculatorState.p2_angle;
            const resultX = centerX + Math.cos(resultAngle) * radius;
            const resultY = centerY + Math.sin(resultAngle) * radius;
            
            // Result vector with white outline
            graphics.lineStyle(10, 0xFFFFFF, 1.0);
            graphics.moveTo(centerX, centerY);
            graphics.lineTo(resultX, resultY);
            graphics.lineStyle(6, 0xFFDD00, 1.0);
            graphics.moveTo(centerX, centerY);
            graphics.lineTo(resultX, resultY);
        } else {
            // Subtraction - show angle between vectors
            const angleDiff = vectorCalculatorState.p1_angle - vectorCalculatorState.p2_angle;
            const resultX = centerX + Math.cos(angleDiff) * radius;
            const resultY = centerY + Math.sin(angleDiff) * radius;
            
            // Difference vector with white outline
            graphics.lineStyle(10, 0xFFFFFF, 1.0);
            graphics.moveTo(centerX, centerY);
            graphics.lineTo(resultX, resultY);
            graphics.lineStyle(6, 0xFF6600, 1.0);
            graphics.moveTo(centerX, centerY);
            graphics.lineTo(resultX, resultY);
        }
        
        // Draw draggable handles with thick white outlines for high visibility
        graphics.lineStyle(5, 0xFFFFFF, 1.0);
        graphics.beginFill(0xFF3333, 1.0);
        graphics.drawCircle(p1x, p1y, 18);
        graphics.endFill();
        
        graphics.lineStyle(5, 0xFFFFFF, 1.0);
        graphics.beginFill(0x33CCCC, 1.0);
        graphics.drawCircle(p2x, p2y, 18);
        graphics.endFill();
        
        // Add angle value labels to show atan2 values
        const p1AngleDeg = (vectorCalculatorState.p1_angle * 180 / Math.PI).toFixed(1);
        const p2AngleDeg = (vectorCalculatorState.p2_angle * 180 / Math.PI).toFixed(1);
        
        // Create text objects for angle values
        const p1Text = new PIXI.Text(`${p1AngleDeg}¬∞`, {
            fontSize: 16,
            fill: 0xFFFFFF,
            fontWeight: 'bold',
            stroke: 0x000000,
            strokeThickness: 3
        });
        p1Text.anchor.set(0.5);
        p1Text.x = p1x + 25;
        p1Text.y = p1y - 25;
        app.stage.addChild(p1Text);
        
        const p2Text = new PIXI.Text(`${p2AngleDeg}¬∞`, {
            fontSize: 16,
            fill: 0xFFFFFF,
            fontWeight: 'bold',
            stroke: 0x000000,
            strokeThickness: 3
        });
        p2Text.anchor.set(0.5);
        p2Text.x = p2x + 25;
        p2Text.y = p2y - 25;
        app.stage.addChild(p2Text);
        
        // Show result angle
        if (vectorCalculatorState.operationMode === 'addition') {
            const resultAngle = vectorCalculatorState.p1_angle + vectorCalculatorState.p2_angle;
            const resultAngleDeg = (resultAngle * 180 / Math.PI).toFixed(1);
            const resultText = new PIXI.Text(`Result: ${resultAngleDeg}¬∞`, {
                fontSize: 18,
                fill: 0xFFDD00,
                fontWeight: 'bold',
                stroke: 0x000000,
                strokeThickness: 3
            });
            resultText.anchor.set(0.5);
            resultText.x = centerX;
            resultText.y = centerY - radius - 40;
            app.stage.addChild(resultText);
        }
    }
    
    // Event handlers
    app.stage.on('pointerdown', (event) => {
        console.log('üßÆ POINTER DOWN detected:', event.data.global);
        const pos = event.data.global;
        const centerX = app.screen.width / 2;
        const centerY = app.screen.height / 2;
        const radius = Math.min(centerX, centerY) * 0.7;
        
        const p1x = centerX + Math.cos(vectorCalculatorState.p1_angle) * radius;
        const p1y = centerY + Math.sin(vectorCalculatorState.p1_angle) * radius;
        const p2x = centerX + Math.cos(vectorCalculatorState.p2_angle) * radius;
        const p2y = centerY + Math.sin(vectorCalculatorState.p2_angle) * radius;
        
        console.log('üßÆ Handle positions - P1:', {x: p1x, y: p1y}, 'P2:', {x: p2x, y: p2y});
        
        // Check if clicking on handles (larger hit area for easier interaction)
        const dist1 = Math.sqrt((pos.x - p1x) ** 2 + (pos.y - p1y) ** 2);
        const dist2 = Math.sqrt((pos.x - p2x) ** 2 + (pos.y - p2y) ** 2);
        
        console.log('üßÆ Distances - P1:', dist1, 'P2:', dist2);
        
        if (dist1 < 30) {
            isDragging = true;
            dragTarget = 'p1';
            console.log('üßÆ Dragging red handle');
        } else if (dist2 < 30) {
            isDragging = true;
            dragTarget = 'p2';
            console.log('üßÆ Dragging blue handle');
        } else {
            console.log('üßÆ Click outside handles');
        }
    });
    
    app.stage.on('pointermove', (event) => {
        if (!isDragging) return;
        
        const pos = event.data.global;
        const centerX = app.screen.width / 2;
        const centerY = app.screen.height / 2;
        
        const angle = Math.atan2(pos.y - centerY, pos.x - centerX);
        
        if (dragTarget === 'p1') {
            vectorCalculatorState.p1_angle = angle;
        } else if (dragTarget === 'p2') {
            vectorCalculatorState.p2_angle = angle;
        }
        
        draw();
    });
    
    app.stage.on('pointerup', () => {
        isDragging = false;
        dragTarget = null;
    });
    
    app.stage.on('pointerupoutside', () => {
        isDragging = false;
        dragTarget = null;
    });
    
    // Hook up dropdown
    const dropdown = document.getElementById('vector-operation');
    if (dropdown) {
        dropdown.addEventListener('change', (e) => {
            vectorCalculatorState.operationMode = e.target.value;
            draw();
        });
    }
    
    // Add resize observer to handle container size changes
    if (window.ResizeObserver) {
        const resizeObserver = new ResizeObserver(() => {
            if (container.offsetWidth > 0 && container.offsetHeight > 0) {
                app.renderer.resize(container.offsetWidth, container.offsetHeight);
                atan2Filter.uniforms.u_resolution = [app.screen.width, app.screen.height];
                backgroundLayer.filterArea = app.screen;
                app.stage.hitArea = app.screen;
                // Resize background layer
                backgroundLayer.clear();
                backgroundLayer.beginFill(0x000000);
                backgroundLayer.drawRect(0, 0, app.screen.width, app.screen.height);
                backgroundLayer.endFill();
                draw(); // This will update u_basis again
            }
        });
        resizeObserver.observe(container);
    }
    
    // Initial draw
    draw();
    
    console.log('Vector Calculator initialized');
}

// Time Series Analyzer Interactive Demo
// Visualizes circular statistics and derivatives for angle sequences

console.log('üìà TIME SERIES ANALYZER: JavaScript file loaded!');

// Global state for the time series analyzer
let timeSeriesState = {
    points: [],
    operationMode: 'average'
};

function initTimeSeriesAnalyzer() {
    console.log('üìà TIME SERIES ANALYZER: Function called!');
    console.log('üìà TIME SERIES ANALYZER: Initializing Time Series Analyzer...');
    
    // Check if PIXI is loaded
    if (typeof PIXI === 'undefined') {
        console.log('PIXI not loaded yet, retrying...');
        setTimeout(initTimeSeriesAnalyzer, 200);
        return;
    }
    
    const container = document.getElementById('timeseries-analyzer-container');
    if (!container) {
        console.log('Time series analyzer container not found');
        return;
    }
    
    // Clean up any existing app for this specific container
    window.interactiveApps ??= new Map();
    const key = container.id;
    const existingApp = window.interactiveApps.get(key);
    if (existingApp) {
        existingApp.destroy(true, { children: true, texture: true, baseTexture: true });
        window.interactiveApps.delete(key);
    }
    
    // Check if container is visible and has dimensions
    if (container.offsetWidth === 0 || container.offsetHeight === 0) {
        console.log('Container not visible yet, retrying...');
        setTimeout(() => initTimeSeriesAnalyzer(), 100);
        return;
    }
    
    // Create PIXI application
    const app = new PIXI.Application({
        width: container.offsetWidth,
        height: container.offsetHeight,
        backgroundColor: 0x000000,
        antialias: true
    });
    
    container.appendChild(app.view);
    window.interactiveApps.set(key, app);
    
    // Create background layer for atan2 filter
    const backgroundLayer = new PIXI.Graphics();
    backgroundLayer.beginFill(0x000000);
    backgroundLayer.drawRect(0, 0, app.screen.width, app.screen.height);
    backgroundLayer.endFill();
    app.stage.addChild(backgroundLayer);
    
    // Enhanced atan2 filter for time series with mean alignment and confidence
    const atan2Filter = new PIXI.Filter(undefined, `
        precision mediump float;
        uniform vec2 u_resolution;
        uniform float u_basis;
        uniform float u_strength;
        uniform float u_step_deg;
        uniform float u_contour_alpha;
        
        vec3 hsl2rgb(float h, float s, float l) {
            float c = (1.0 - abs(2.0 * l - 1.0)) * s;
            float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
            float m = l - c / 2.0;
            
            vec3 rgb;
            if (h < 1.0/6.0) {
                rgb = vec3(c, x, 0.0);
            } else if (h < 2.0/6.0) {
                rgb = vec3(x, c, 0.0);
            } else if (h < 3.0/6.0) {
                rgb = vec3(0.0, c, x);
            } else if (h < 4.0/6.0) {
                rgb = vec3(0.0, x, c);
            } else if (h < 5.0/6.0) {
                rgb = vec3(x, 0.0, c);
            } else {
                rgb = vec3(c, 0.0, x);
            }
            
            return rgb + m;
        }
        
        void main() {
            vec2 centered_coord = gl_FragCoord.xy - u_resolution / 2.0;
            float raw_angle = atan(centered_coord.y, centered_coord.x);
            
            // Apply basis rotation - field aligns with circular mean
            float angle = raw_angle - u_basis;
            
            float hue = (angle + 3.14159265) / (2.0 * 3.14159265);
            float distance = length(centered_coord) / min(u_resolution.x, u_resolution.y) * 2.0;
            
            // Modulate lightness by strength (|R|) - bright when clustered, dim when spread
            float base_lightness = 0.2 + 0.3 * (1.0 - min(distance, 1.0));
            float lightness = base_lightness + 0.4 * u_strength;
            
            // Add contour lines for geometric structure
            float step_rad = u_step_deg * 3.14159265 / 180.0;
            float contour_dist = abs(mod(angle + 3.14159265, step_rad) - step_rad * 0.5);
            float contour_line = 1.0 - smoothstep(0.0, 0.02, contour_dist);
            
            vec3 base_color = hsl2rgb(hue, 0.6, lightness);
            vec3 contour_color = mix(base_color, vec3(1.0), contour_line * u_contour_alpha);
            
            gl_FragColor = vec4(contour_color, 1.0);
        }
    `, {
        u_resolution: [app.screen.width, app.screen.height],
        u_basis: 0.0,
        u_strength: 0.0,
        u_step_deg: 15.0,
        u_contour_alpha: 0.2
    });
    
    // Apply background filter only to background layer
    backgroundLayer.filterArea = app.screen;
    backgroundLayer.filters = [atan2Filter];
    
    // Create graphics objects on top of background
    const graphics = new PIXI.Graphics();
    app.stage.addChild(graphics);
    
    // Make stage interactive (PIXI v7 API)
    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;
    app.stage.cursor = 'crosshair';
    
    console.log('üìà Interactive setup - eventMode:', app.stage.eventMode, 'hitArea:', app.stage.hitArea);
    console.log('üìà Stage interactive?', app.stage.interactive);
    console.log('üìà Stage children count:', app.stage.children.length);
    
    // Circular mean calculation
    function calculateCircularMean(angles) {
        if (angles.length === 0) return 0;
        
        let x = 0, y = 0;
        for (const angle of angles) {
            x += Math.cos(angle);
            y += Math.sin(angle);
        }
        return Math.atan2(y, x);
    }
    
    // Calculate finite differences (derivatives)
    function calculateDerivatives(angles) {
        if (angles.length < 2) return [];
        
        const derivatives = [];
        for (let i = 1; i < angles.length; i++) {
            let diff = angles[i] - angles[i-1];
            
            // Handle angle wraparound
            if (diff > Math.PI) diff -= 2 * Math.PI;
            if (diff < -Math.PI) diff += 2 * Math.PI;
            
            derivatives.push(diff);
        }
        return derivatives;
    }
    
    // Drawing function
    function draw() {
        graphics.clear();
        
        // Update field uniforms based on current data
        if (timeSeriesState.points.length > 0) {
            const angles = timeSeriesState.points.map(p => p.angle);
            
            if (timeSeriesState.operationMode === 'average') {
                // Calculate circular mean and strength
                const meanAngle = calculateCircularMean(angles);
                
                // Calculate |R| for confidence/strength
                let x = 0, y = 0;
                for (const angle of angles) {
                    x += Math.cos(angle);
                    y += Math.sin(angle);
                }
                const strength = Math.sqrt(x*x + y*y) / angles.length; // |R|
                
                // Align field with mean, brightness shows confidence
                atan2Filter.uniforms.u_basis = meanAngle;
                atan2Filter.uniforms.u_strength = strength;
            } else {
                // For derivatives mode, use global field
                atan2Filter.uniforms.u_basis = 0.0;
                atan2Filter.uniforms.u_strength = 0.5; // Neutral brightness
            }
        } else {
            // No points yet, neutral field
            atan2Filter.uniforms.u_basis = 0.0;
            atan2Filter.uniforms.u_strength = 0.0;
        }
        
        const centerX = app.screen.width / 2;
        const centerY = app.screen.height / 2;
        const radius = Math.min(centerX, centerY) * 0.7;
        
        // Draw unit circle
        graphics.lineStyle(2, 0xFFFFFF, 0.3);
        graphics.drawCircle(centerX, centerY, radius);
        
        // Draw all clicked points
        timeSeriesState.points.forEach((point, index) => {
            const x = centerX + Math.cos(point.angle) * radius;
            const y = centerY + Math.sin(point.angle) * radius;
            
            // Draw point
            graphics.beginFill(0xFFFFFF, 0.8);
            graphics.drawCircle(x, y, 6);
            graphics.endFill();
            
            // Draw line from center
            graphics.lineStyle(2, 0xFFFFFF, 0.4);
            graphics.moveTo(centerX, centerY);
            graphics.lineTo(x, y);
            
            // Draw index number
            const text = new PIXI.Text(index.toString(), {
                fontSize: 12,
                fill: 0xFFFFFF
            });
            text.anchor.set(0.5);
            text.x = x + 15;
            text.y = y - 15;
            app.stage.addChild(text);
        });
        
        if (timeSeriesState.points.length === 0) return;
        
        const angles = timeSeriesState.points.map(p => p.angle);
        
        if (timeSeriesState.operationMode === 'average') {
            // Draw circular mean
            const meanAngle = calculateCircularMean(angles);
            const meanX = centerX + Math.cos(meanAngle) * radius;
            const meanY = centerY + Math.sin(meanAngle) * radius;
            
            graphics.lineStyle(8, 0xFFE66D);
            graphics.moveTo(centerX, centerY);
            graphics.lineTo(meanX, meanY);
            
            // Draw mean point
            graphics.beginFill(0xFFE66D);
            graphics.drawCircle(meanX, meanY, 12);
            graphics.endFill();
            
        } else if (timeSeriesState.operationMode === 'derivatives') {
            // Draw derivatives (finite differences)
            const derivatives = calculateDerivatives(angles);
            
            derivatives.forEach((derivative, index) => {
                const derivX = centerX + Math.cos(derivative) * radius * 0.6;
                const derivY = centerY + Math.sin(derivative) * radius * 0.6;
                
                // Use different colors for different derivatives
                const colors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFECA57, 0xFF9FF3];
                const color = colors[index % colors.length];
                
                graphics.lineStyle(6, color);
                graphics.moveTo(centerX, centerY);
                graphics.lineTo(derivX, derivY);
                
                // Draw derivative point
                graphics.beginFill(color);
                graphics.drawCircle(derivX, derivY, 8);
                graphics.endFill();
            });
        }
    }
    
    // Event handlers
    console.log('üìà Setting up event handlers...');
    
    app.stage.on('pointerdown', (event) => {
        console.log('üìà POINTER DOWN detected:', event.data.global);
        const pos = event.data.global;
        const centerX = app.screen.width / 2;
        const centerY = app.screen.height / 2;
        
        const angle = Math.atan2(pos.y - centerY, pos.x - centerX);
        
        console.log('üìà Adding point at angle:', angle);
        
        // Add new point
        timeSeriesState.points.push({ angle: angle });
        draw();
        
        console.log('üìà Total points now:', timeSeriesState.points.length);
    });
    
    app.stage.on('pointermove', (event) => {
        // Just a test to see if ANY events work
        console.log('üìà POINTER MOVE detected');
    });
    
    // Hook up dropdown
    const dropdown = document.getElementById('timeseries-operation');
    if (dropdown) {
        dropdown.addEventListener('change', (e) => {
            timeSeriesState.operationMode = e.target.value;
            draw();
        });
    }
    
    // Hook up clear button
    const clearButton = document.getElementById('clear-points');
    if (clearButton) {
        clearButton.addEventListener('click', () => {
            timeSeriesState.points = [];
            // Remove all text objects
            app.stage.children = app.stage.children.filter(child => !(child instanceof PIXI.Text));
            draw();
        });
    }
    
    // Add resize observer to handle container size changes
    if (window.ResizeObserver) {
        const resizeObserver = new ResizeObserver(() => {
            if (container.offsetWidth > 0 && container.offsetHeight > 0) {
                app.renderer.resize(container.offsetWidth, container.offsetHeight);
                atan2Filter.uniforms.u_resolution = [app.screen.width, app.screen.height];
                backgroundLayer.filterArea = app.screen;
                app.stage.hitArea = app.screen;
                // Resize background layer
                backgroundLayer.clear();
                backgroundLayer.beginFill(0x000000);
                backgroundLayer.drawRect(0, 0, app.screen.width, app.screen.height);
                backgroundLayer.endFill();
                draw(); // This will update u_basis and u_strength again
            }
        });
        resizeObserver.observe(container);
    }
    
    // Initial draw
    draw();
    
    console.log('Time Series Analyzer initialized');
}


    </script>
</body>
</html>