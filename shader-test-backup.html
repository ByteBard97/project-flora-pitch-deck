<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>NPR Shader Test</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #0f4a3c;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .container {
      background: rgba(255, 255, 255, 0.1);
      padding: 40px;
      border-radius: 12px;
      text-align: center;
    }
    h1 {
      color: #34d399;
      margin: 0 0 20px 0;
    }
    #nprShaderCanvas {
      width: 512px;
      height: 512px;
      display: block;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      background: white;
    }
    .info {
      color: white;
      margin-top: 20px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>NPR Shader Test</h1>
    <canvas id="nprShaderCanvas"></canvas>
    <div class="info">Check browser console for debug info</div>
  </div>

<script>
// Initialize NPR shader demo
function initShader() {
  const canvas = document.getElementById('nprShaderCanvas');
  if (!canvas) {
    console.error('Canvas not found!');
    return;
  }
  console.log('Initializing shader on canvas:', canvas);

  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  if (!gl) {
    console.error('WebGL not supported');
    return;
  }

  // Set canvas size to match display size
  const rect = canvas.getBoundingClientRect();
  const size = Math.min(rect.width, rect.height) || 512;
  canvas.width = size;
  canvas.height = size;

  console.log('Canvas size:', canvas.width, 'x', canvas.height);

  // Vertex shader (standard quad)
  const vertexShaderSource = `
    attribute vec2 position;
    void main() {
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;

  // Fragment shader (ShaderToy code with helper functions from common.glsl)
  const fragmentShaderSource = `
    precision highp float;
    uniform vec2 iResolution;
    uniform float iTime;

    // Helper functions from common.glsl
    mat2 rot2(float a) {
      float c = cos(a);
      float s = sin(a);
      return mat2(c, -s, s, c);
    }

    float hash21(vec2 p) {
      return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831589)) * 43758.5453);
    }

    float n2D(vec2 p) {
      const vec2 s = vec2(1.0, 113.0);
      vec2 ip = floor(p);
      p -= ip;
      vec4 h = vec4(0.0, s.x, s.y, s.x + s.y) + dot(ip, s);
      p = p * p * (3.0 - 2.0 * p);
      h = fract(sin(mod(h, 6.2831589)) * 43758.5453);
      h.xy = mix(h.xy, h.zw, p.y);
      return mix(h.x, h.y, p.x);
    }

    float fbm(vec2 p) {
      return n2D(p) * 0.533 + n2D(p * 2.0) * 0.267 + n2D(p * 4.0) * 0.133 + n2D(p * 8.0) * 0.067;
    }

    float sdHexagon(vec2 p, float r) {
      const vec3 k = vec3(-0.8660254, 0.5, 0.57735);
      p = abs(p);
      p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;
      return length(p - vec2(clamp(p.x, -k.z * r, k.z * r), r)) * sign(p.y - r);
    }

    float lBox(vec2 p, vec2 a, vec2 b, float ew) {
      float ang = atan(b.y - a.y, b.x - a.x);
      p = rot2(ang) * (p - mix(a, b, 0.5));
      vec2 l = vec2(length(b - a), ew);
      vec2 d = abs(p) - (l + ew) / 2.0;
      return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
    }

    vec3 pencil(vec3 col, vec2 p) {
      vec2 q = p * 4.0;
      const vec2 sc = vec2(1.0, 12.0);
      q += (vec2(n2D(q * 4.0), n2D(q * 4.0 + 7.3)) - 0.5) * 0.03;
      q = rot2(-3.14159 / 2.5) * q;
      col = min(col, 1.0);
      float gr = dot(col, vec3(0.299, 0.587, 0.114));
      float ns = n2D(q * sc) * 0.66 + n2D(q * 2.0 * sc) * 0.34;
      q = rot2(3.14159 / 2.0) * q;
      float ns2 = n2D(q * sc) * 0.66 + n2D(q * 2.0 * sc) * 0.34;
      q = rot2(-3.14159 / 5.0) * q;
      float ns3 = n2D(q * sc) * 0.66 + n2D(q * 2.0 * sc) * 0.34;
      ns = 0.5 + (gr - max(max(ns, ns2), ns3));
      return vec3(clamp(ns, 0.0, 1.0));
    }

    void main() {
      vec2 fragCoord = gl_FragCoord.xy;
      vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;

      float gSc = 1.0;
      float sf = gSc / iResolution.y;

      vec2 offs = vec2(fbm(uv * 16.0), fbm(uv * 16.0 + 0.35));
      vec2 offs2 = vec2(fbm(uv + iTime / 4.0), fbm(uv + 0.5 + iTime / 4.0));
      vec2 p = uv * gSc - (offs - 0.5) * 0.007 - (offs2 - 0.5) * 0.05;

      // Background
      vec3 col = vec3(0.95, 0.975, 1.0);

      // Graph paper
      float dim = 9.0;
      vec2 q = abs(mod(p, 1.0 / dim) - 0.5 / dim);
      float ln3 = abs(max(q.x, q.y) - 0.5 / dim);
      col = mix(col, vec3(0.35, 0.65, 1.0), (1.0 - smoothstep(0.0, sf * 2.0, ln3)) * 0.8);

      dim *= 2.0;
      q = abs(mod(p, 1.0 / dim) - 0.5 / dim);
      ln3 = max(abs(max(q.x, q.y) - 0.5 / dim), -ln3);
      col = mix(col, vec3(0.35, 0.65, 1.0), (1.0 - smoothstep(0.0, sf * 2.0, ln3)) * 0.65);

      // Lighting
      vec3 lp = vec3(-0.75, 3.0, -1.5);
      vec3 ld = normalize(lp - vec3(uv, 0.0));
      col *= clamp(dot(normalize(vec3(p, -1.5)), ld), 0.0, 1.0) * 0.2 + 0.8;
      col *= fbm(p * 8.0) * 0.1 + 0.9;

      // 12 hexagons
      float cR = 0.3;
      float sL = 0.087;
      float a0 = 6.2831 / 24.0;
      float dA = 6.2831 / 12.0;
      float gHex = 1e5;

      vec2 q2;
      float dH;
      vec3 rnbCol;

      // Unroll hexagons manually (no loops for WebGL 1.0 compatibility)
      q2 = rot2(-dA * 0.0) * (p - rot2(dA * 11.0) * vec2(0.0, cR));
      dH = sdHexagon(q2, sL / 2.0);
      rnbCol = 0.6 + 0.4 * cos(6.2831 * 0.0 / 12.0 + vec3(0.0, 1.0, 2.0) * 1.5 + 3.14159 / 6.0);
      col = mix(col, rnbCol, 1.0 - smoothstep(0.0, sf, dH));
      gHex = min(gHex, dH);

      q2 = rot2(-dA * 1.0) * (p - rot2(dA * 10.0) * vec2(0.0, cR));
      dH = sdHexagon(q2, sL / 2.0);
      rnbCol = 0.6 + 0.4 * cos(6.2831 * 1.0 / 12.0 + vec3(0.0, 1.0, 2.0) * 1.5 + 3.14159 / 6.0);
      col = mix(col, rnbCol, 1.0 - smoothstep(0.0, sf, dH));
      gHex = min(gHex, dH);

      q2 = rot2(-dA * 2.0) * (p - rot2(dA * 9.0) * vec2(0.0, cR));
      dH = sdHexagon(q2, sL / 2.0);
      rnbCol = 0.6 + 0.4 * cos(6.2831 * 2.0 / 12.0 + vec3(0.0, 1.0, 2.0) * 1.5 + 3.14159 / 6.0);
      col = mix(col, rnbCol, 1.0 - smoothstep(0.0, sf, dH));
      gHex = min(gHex, dH);

      // Pencil overlay
      vec3 colP = pencil(col, p * 8.0 * iResolution.y / 450.0);
      col = mix(col, 1.0 - exp(-(col * 2.0) * (colP + 0.25)), 0.85);

      // Paper grain
      vec2 pp = p * 8.0;
      vec3 rn3 = vec3(hash21(pp), hash21(pp + 2.37), hash21(pp + 4.83));
      vec3 pg = 0.8 + (rn3.xyz * 0.35 + rn3.xxx * 0.65) * 0.4;
      col *= min(pg, 1.0);

      gl_FragColor = vec4(sqrt(max(col, 0.0)), 1.0);
    }
  `;

  // Compile shaders
  function compileShader(source, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
  const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

  if (!vertexShader || !fragmentShader) return;

  // Link program
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    return;
  }

  gl.useProgram(program);

  // Setup geometry (fullscreen quad)
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
     1,  1
  ]), gl.STATIC_DRAW);

  const positionLocation = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  // Get uniform locations
  const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
  const iTimeLocation = gl.getUniformLocation(program, 'iTime');

  // Set viewport
  gl.viewport(0, 0, canvas.width, canvas.height);
  console.log('Viewport set to:', canvas.width, 'x', canvas.height);

  // Render loop
  let startTime = Date.now();
  function render() {
    const currentTime = (Date.now() - startTime) / 1000.0;

    gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
    gl.uniform1f(iTimeLocation, currentTime);

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
  }

  console.log('Starting render loop');
  render();
}

// Try to initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initShader);
} else {
  initShader();
}

// Also try again on window load
window.addEventListener('load', function() {
  const canvas = document.getElementById('nprShaderCanvas');
  if (canvas && !canvas.getContext('webgl')) {
    initShader();
  }
});
</script>
</body>
</html>
